#ifndef _mHardwarePins_H_
#define _mHardwarePins_H_

#define   D_UNIQUE_MODULE_CORE_HARDWAREPINS_ID ((2*1000)+5)

// MapConfig serves the purpose of feeding the template methods until successful saving of states are archieved
// In the near future, this mode will be tested by feeding the template via http command

#include "1_TaskerManager/mTaskerManager.h"


#ifdef ESP8266
  #include "mHardwarePins_Esp82xx.h"
#endif
#ifdef ESP32
  #include "mHardwarePins_Esp32.h"
#endif

#include "1_TaskerManager/mTaskerInterface.h"
  
#include "jsmn.h"


#ifdef ENABLE_DEVFEATURE_PINS__GPIO_VIEWER_LIBRARY
#include <gpio_viewer.h> // Must me the first include in your project
#endif


#ifdef DEBUG_PIN1_GPIO
  #define DEBUG_PIN1_INIT()     pinMode(DEBUG_PIN1_GPIO, OUTPUT); digitalWrite(DEBUG_PIN1_GPIO, HIGH);
  #define DEBUG_PIN1_SET(X)     digitalWrite(DEBUG_PIN1_GPIO, X);
  #define DEBUG_PIN1_TOGGLE()   digitalWrite(DEBUG_PIN1_GPIO, !digitalRead(DEBUG_PIN1_GPIO));
#else
  #define DEBUG_PIN1_INIT()
  #define DEBUG_PIN1_SET(X)
  #define DEBUG_PIN1_TOGGLE()
#endif
#ifdef DEBUG_PIN2_GPIO
  #define DEBUG_PIN2_INIT()     pinMode(DEBUG_PIN2_GPIO, OUTPUT); digitalWrite(DEBUG_PIN2_GPIO, HIGH);
  #define DEBUG_PIN2_SET(X)     digitalWrite(DEBUG_PIN2_GPIO, X);
  #define DEBUG_PIN2_TOGGLE()   digitalWrite(DEBUG_PIN2_GPIO, !digitalRead(DEBUG_PIN2_GPIO));
#else
  #define DEBUG_PIN2_INIT()

  #define DEBUG_PIN2_SET(X)
  #define DEBUG_PIN2_TOGGLE()
#endif
#ifdef DEBUG_PIN3_GPIO
  #define DEBUG_PIN3_INIT()     pinMode(DEBUG_PIN3_GPIO, OUTPUT); digitalWrite(DEBUG_PIN3_GPIO, HIGH);
  #define DEBUG_PIN3_SET(X)     digitalWrite(DEBUG_PIN3_GPIO, X);
  #define DEBUG_PIN3_TOGGLE()   digitalWrite(DEBUG_PIN3_GPIO, !digitalRead(DEBUG_PIN3_GPIO));
#else 
  #define DEBUG_PIN3_INIT()
  #define DEBUG_PIN3_SET(X)
  #define DEBUG_PIN3_TOGGLE()
#endif
#ifdef DEBUG_PIN4_GPIO
  #define DEBUG_PIN4_INIT()     pinMode(DEBUG_PIN4_GPIO, OUTPUT); digitalWrite(DEBUG_PIN4_GPIO, HIGH);
  #define DEBUG_PIN4_SET(X)     digitalWrite(DEBUG_PIN4_GPIO, X);
  #define DEBUG_PIN4_TOGGLE()   digitalWrite(DEBUG_PIN4_GPIO, !digitalRead(DEBUG_PIN4_GPIO));
#else
  #define DEBUG_PIN4_INIT()
  #define DEBUG_PIN4_SET(X)
  #define DEBUG_PIN4_TOGGLE()
#endif
#ifdef DEBUG_PIN5_GPIO
  #define DEBUG_PIN5_INIT()     pinMode(DEBUG_PIN5_GPIO, OUTPUT); digitalWrite(DEBUG_PIN5_GPIO, HIGH);
  #define DEBUG_PIN5_SET(X)     digitalWrite(DEBUG_PIN5_GPIO, X);
  #define DEBUG_PIN5_TOGGLE()   digitalWrite(DEBUG_PIN5_GPIO, !digitalRead(DEBUG_PIN5_GPIO));
#else
  #define DEBUG_PIN5_INIT()
  #define DEBUG_PIN5_SET(X)
  #define DEBUG_PIN5_TOGGLE()
#endif
#ifdef DEBUG_PIN6_GPIO
  #define DEBUG_PIN6_INIT()     pinMode(DEBUG_PIN6_GPIO, OUTPUT); digitalWrite(DEBUG_PIN6_GPIO, HIGH);
  #define DEBUG_PIN6_SET(X)     digitalWrite(DEBUG_PIN6_GPIO, X);
  #define DEBUG_PIN6_TOGGLE()   digitalWrite(DEBUG_PIN6_GPIO, !digitalRead(DEBUG_PIN6_GPIO));
#else
  #define DEBUG_PIN6_INIT()
  #define DEBUG_PIN6_SET(X)
  #define DEBUG_PIN6_TOGGLE()
#endif
#ifdef DEBUG_PIN7_GPIO
  #define DEBUG_PIN7_INIT()     pinMode(DEBUG_PIN7_GPIO, OUTPUT); digitalWrite(DEBUG_PIN7_GPIO, HIGH);
  #define DEBUG_PIN7_SET(X)     digitalWrite(DEBUG_PIN7_GPIO, X);
  #define DEBUG_PIN7_TOGGLE()   digitalWrite(DEBUG_PIN7_GPIO, !digitalRead(DEBUG_PIN7_GPIO));
#else
  #define DEBUG_PIN7_INIT()
  #define DEBUG_PIN7_SET(X)
  #define DEBUG_PIN7_TOGGLE()
#endif
#ifdef DEBUG_PIN8_GPIO
  #define DEBUG_PIN8_INIT()     pinMode(DEBUG_PIN8_GPIO, OUTPUT); digitalWrite(DEBUG_PIN8_GPIO, HIGH);
  #define DEBUG_PIN8_SET(X)     digitalWrite(DEBUG_PIN8_GPIO, X);
  #define DEBUG_PIN8_TOGGLE()   digitalWrite(DEBUG_PIN8_GPIO, !digitalRead(DEBUG_PIN8_GPIO));
#else
  #define DEBUG_PIN8_INIT()
  #define DEBUG_PIN8_SET(X)
  #define DEBUG_PIN8_TOGGLE()
#endif


/**
 * @brief Enum list defining all GPIO functions that is fixed, unique and non changing across builds and hardware
 * @note This list will always be created in its full form
 * @note INV = Inverted pin, low/ground is active
 * @note NP  = No pullup/down 
 * @note Never add `#ifdef` into this enum, as I want all GPIO to always exist and be static for long term debug. `ifdef` should be considered around nicelist
 * @note PD = Pulled down (hardware dependant)
 */
enum GPIO2_COMPLETE_STATIC_LIST_IDS2 : uint16_t {
  // Default for unused
  GPIO2_NONE_ID = 0,
  GPIO2_ANALOG_ID, // basic analog that any enabled modules can use on the esp8266, this will need changed to be numbers so esp8266 defaults to 1 and esp32 cna use them all

  // DHT11/22 pins (enabled auto detect?)
  GPIO2_DHT11_1OF2_ID, GPIO2_DHT11_2OF2_ID,
  // DHT22
  GPIO2_DHT22_1OF2_ID, GPIO2_DHT22_2OF2_ID,
  // DallasTemperaure 1-wire sensor
  GPIO2_DSB_1OF2_ID, GPIO2_DSB_2OF2_ID,
  // I2C
  GPIO2_I2C_SCL_ID, GPIO2_I2C_SDA_ID,

  // With IC connects that need to be set high/low when unused for stability eg level shifters
  GPIO2_UNUSED_FORCED_HIGH_ID,
  GPIO2_UNUSED_FORCED_LOW_ID,

  // // Addressable RGB(w) leds
  // GPIO2_RGB_DATA_ID, GPIO2_RGB_CLOCK_ID,
  // GPIO2_RGB_DATA1_ID, GPIO2_RGB_DATA2_ID, GPIO2_RGB_DATA3_ID, GPIO2_RGB_DATA4_ID,  // needs to be done in this order
  // GPIO2_RGB_CLOCK1_ID, GPIO2_RGB_CLOCK2_ID, GPIO2_RGB_CLOCK3_ID, GPIO2_RGB_CLOCK4_ID,
  
  // IR Transceiver
  GPIO2_IRSEND_ID, GPIO2_IRRECV_ID,
  // Switches = 8. User connected external switches (No longer using offset, making discrete options)
  GPIO2_SWT1_ID,        GPIO2_SWT2_ID,        GPIO2_SWT3_ID, GPIO2_SWT4_ID, GPIO2_SWT5_ID, GPIO2_SWT6_ID, GPIO2_SWT7_ID, GPIO2_SWT8_ID,
  GPIO2_SWT1_INV_ID,    GPIO2_SWT2_INV_ID,    GPIO2_SWT3_INV_ID, GPIO2_SWT4_INV_ID, GPIO2_SWT5_INV_ID, GPIO2_SWT6_INV_ID, GPIO2_SWT7_INV_ID, GPIO2_SWT8_INV_ID,
  GPIO2_SWT1_NP_ID,     GPIO2_SWT2_NP_ID,     GPIO2_SWT3_NP_ID, GPIO2_SWT4_NP_ID, GPIO2_SWT5_NP_ID, GPIO2_SWT6_NP_ID, GPIO2_SWT7_NP_ID, GPIO2_SWT8_NP_ID,
  GPIO2_SWT1_INV_NP_ID, GPIO2_SWT2_INV_NP_ID, GPIO2_SWT3_INV_NP_ID, GPIO2_SWT4_INV_NP_ID, GPIO2_SWT5_INV_NP_ID, GPIO2_SWT6_INV_NP_ID, GPIO2_SWT7_INV_NP_ID, GPIO2_SWT8_INV_NP_ID,
  // Buttons = 4 (rename keys to buttons)
  GPIO2_KEY1_ID, GPIO2_KEY2_ID, GPIO2_KEY3_ID, GPIO2_KEY4_ID, GPIO2_KEY5_ID, GPIO2_KEY6_ID, GPIO2_KEY7_ID, GPIO2_KEY8_ID,
  GPIO2_KEY1_INV_ID, GPIO2_KEY2_INV_ID, GPIO2_KEY3_INV_ID, GPIO2_KEY4_INV_ID, GPIO2_KEY5_INV_ID, GPIO2_KEY6_INV_ID, GPIO2_KEY7_INV_ID, GPIO2_KEY8_INV_ID,
  GPIO2_KEY1_NP_ID, GPIO2_KEY2_NP_ID, GPIO2_KEY3_NP_ID, GPIO2_KEY4_NP_ID, GPIO2_KEY5_NP_ID, GPIO2_KEY6_NP_ID, GPIO2_KEY7_NP_ID, GPIO2_KEY8_NP_ID, 
  GPIO2_KEY1_INV_NP_ID, GPIO2_KEY2_INV_NP_ID, GPIO2_KEY3_INV_NP_ID, GPIO2_KEY4_INV_NP_ID, GPIO2_KEY5_INV_NP_ID, GPIO2_KEY6_INV_NP_ID, GPIO2_KEY7_INV_NP_ID, GPIO2_KEY8_INV_NP_ID,
  //GPIO2_KEY1_PULLDOWN_ID,GPIO2_KEY2_PULLDOWN_ID,GPIO2_KEY3_PULLDOWN_ID,GPIO2_KEY4_PULLDOWN_ID,GPIO2_KEY5_PULLDOWN_ID,GPIO2_KEY6_PULLDOWN_ID,GPIO2_KEY7_PULLDOWN_ID,GPIO2_KEY8_PULLDOWN_ID, // only some buttons can be pulldown enabled
  //unknown button options?
  GPIO2_CNTR1_ID, GPIO2_CNTR2_ID, GPIO2_CNTR3_ID, GPIO2_CNTR4_ID,
  GPIO2_CNTR1_NP_ID, GPIO2_CNTR2_NP_ID, GPIO2_CNTR3_NP_ID, GPIO2_CNTR4_NP_ID,
  // Relays
  GPIO2_REL1_ID, GPIO2_REL2_ID, GPIO2_REL3_ID, GPIO2_REL4_ID, GPIO2_REL5_ID, GPIO2_REL6_ID, GPIO2_REL7_ID, GPIO2_REL8_ID,
  GPIO2_REL1_INV_ID, GPIO2_REL2_INV_ID, GPIO2_REL3_INV_ID, GPIO2_REL4_INV_ID, GPIO2_REL5_INV_ID, GPIO2_REL6_INV_ID, GPIO2_REL7_INV_ID, GPIO2_REL8_INV_ID,
  // PWM 2023: PWM Channels are no longer part of lighting
  GPIO2_PWM1_ID, GPIO2_PWM2_ID, GPIO2_PWM3_ID, GPIO2_PWM4_ID, GPIO2_PWM5_ID,
  GPIO2_PWM1_INV_ID, GPIO2_PWM2_INV_ID, GPIO2_PWM3_INV_ID, GPIO2_PWM4_INV_ID, GPIO2_PWM5_INV_ID,
  // LEDs
  GPIO2_LED1_ID, GPIO2_LED2_ID, GPIO2_LED3_ID, GPIO2_LED4_ID,
  GPIO2_LED1_INV_ID, GPIO2_LED2_INV_ID, GPIO2_LED3_INV_ID, GPIO2_LED4_INV_ID,
  // MH-Z19 Serial interface
  GPIO2_MHZ_TXD_ID, GPIO2_MHZ_RXD_ID,
  // SenseAir Serial interface
  GPIO2_SAIR_TX_ID, GPIO2_SAIR_RX_ID,
  // SPI Chip Select, SPI Data Direction
  GPIO2_SPI_CS_ID, GPIO2_SPI_DC_ID,
  // Serial Bridge Serial interface
  GPIO2_SBR_TX_ID, GPIO2_SBR_RX_ID,
  // SR04 ultrasonic
  GPIO2_SR04_TRIG_ID, GPIO2_SR04_ECHO_ID,
  // Rotary Encoder (e.g. LPD3806-360BM-G5-24C)
  GPIO2__ROTARY_ENCODER_A__ID, GPIO2__ROTARY_ENCODER_B__ID,
  // LDR Basic
  GPIO2_LDR_BASIC_DIGITAL1_ID, GPIO2_LDR_BASIC_ANALOG1_ID,
  GPIO2_LDR_BASIC_DIGITAL2_ID, GPIO2_LDR_BASIC_ANALOG2_ID,
  // SDMxx interfaces
  GPIO2_SDM120_TX_ID, GPIO2_SDM120_RX_ID, GPIO2_SDM630_TX_ID, GPIO2_SDM630_RX_ID,
  // PZEM0XX Serial interface, PZEM004T Serial interface, PZEM-014_ID,016 Serial Modbus interface, PZEM-003_ID,017 Serial Modbus interface 
  GPIO2_PZEM0XX_TX_ID, GPIO2_PZEM004_RX_ID, GPIO2_PZEM0XX_RX_MODBUS_ID, GPIO2_PZEM017_RX_ID,
  // HX711 Load Cell
  GPIO2_HX711_SCK_ID, GPIO2_HX711_DAT_ID,
  // RF Transceiver
  GPIO2_RFSEND_ID, GPIO2_RFRECV_ID,
  // Tuya Serial interface
  GPIO2_TUYA_TX_ID, GPIO2_TUYA_RX_ID,
  // Software SPI (Master Input Slave Output, Master Output Slave Input, Serial Clock, Chip Select, Data or Command)
  GPIO2_SSPI_MISO_ID, GPIO2_SSPI_MOSI_ID, GPIO2_SSPI_SCLK_ID, GPIO2_SSPI_CS_ID, GPIO2_SSPI_DC_ID,
  // Energy monitor chip = MCP39F501 Serial interface (Shelly2)
  GPIO2_MCP39F5_TX_ID, GPIO2_MCP39F5_RX_ID, GPIO2_MCP39F5_RST_ID,
  // CSE7766 Serial interface (S31 and Pow R2)
  GPIO2_CSE7766_TX_ID, GPIO2_CSE7766_RX_ID,
  // 433 MHz SAW Radio transceivers  
  GPIO2_RF_433MHZ_RX_ID, GPIO2_RF_433MHZ_TX_ID,
  // Serial pins (Auto detect hardware vs serial)
  // GPIO2_SERIAL_TX_ID, GPIO2_SERIAL_RX_ID, //phase out to more specific one below
  GPIO2_HWSERIAL0_TX_ID, GPIO2_HWSERIAL0_RX_ID,
  GPIO2_HWSERIAL1_TX_ID, GPIO2_HWSERIAL1_RX_ID,
  GPIO2_HWSERIAL2_TX_ID, GPIO2_HWSERIAL2_RX_ID,
  GPIO2_SWSERIAL0_TX_ID, GPIO2_SWSERIAL0_RX_ID,
  // RingBuffers are used on the receive data (PHASE OUT)
  GPIO2_HWSERIAL0_RING_BUFFER_TX_ID, GPIO2_HWSERIAL0_RING_BUFFER_RX_ID,       // RinfBuffer GPIO should be removed, and instead be a special mode of the serial class. Simply set TX/RX, then with another command enable ringbuffer when desired. 
  GPIO2_HWSERIAL1_RING_BUFFER_TX_ID, GPIO2_HWSERIAL1_RING_BUFFER_RX_ID,
  GPIO2_HWSERIAL2_RING_BUFFER_TX_ID, GPIO2_HWSERIAL2_RING_BUFFER_RX_ID,

  GPIO2_SERIAL_DEBUG_TX_ID, GPIO2_SERIAL_DEBUG_RX_ID,
  // GPS Serial0 on both esp devices (1 of 3)
  GPIO2_GPS_SERIAL0_TX_ID, GPIO2_GPS_SERIAL0_RX_ID,


  // /**
  //  * @brief MAVLink Decoder
  //  **/
  // GPIO2_MAVLINK_DECODER_HWSERIAL0_TX_ID, GPIO2_MAVLINK_DECODER_HWSERIAL0_RX_ID,
  // GPIO2_MAVLINK_DECODER_HWSERIAL1_TX_ID, GPIO2_MAVLINK_DECODER_HWSERIAL1_RX_ID,
  // GPIO2_MAVLINK_DECODER_HWSERIAL2_TX_ID, GPIO2_MAVLINK_DECODER_HWSERIAL2_RX_ID,
  // /**
  //  * @brief MAVLink Telemetry Passthrough
  //  **/
  // GPIO2_MAVLINK_TELEMETRY_HWSERIAL0_TX_ID, GPIO2_MAVLINK_TELEMETRY_HWSERIAL0_RX_ID,
  // GPIO2_MAVLINK_TELEMETRY_HWSERIAL1_TX_ID, GPIO2_MAVLINK_TELEMETRY_HWSERIAL1_RX_ID,
  // GPIO2_MAVLINK_TELEMETRY_HWSERIAL2_TX_ID, GPIO2_MAVLINK_TELEMETRY_HWSERIAL2_RX_ID,



  // Rotary switch
  GPIO2_ROT1A_ID, GPIO2_ROT1B_ID, GPIO2_ROT2A_ID, GPIO2_ROT2B_ID,
  // // PIR Motion 
  // GPIO2_PIR_1_ID, GPIO2_PIR_2_ID, GPIO2_PIR_3_ID,         //pullup
  // GPIO2_PIR_1_NP_ID, GPIO2_PIR_2_NP_ID, GPIO2_PIR_3_NP_ID,
  // GPIO2_PIR_1_NP_INV_ID, GPIO2_PIR_2_NP_INV_ID, GPIO2_PIR_3_NP_INV_ID,
  // GPIO2_PIR_1_INV_ID, GPIO2_PIR_2_INV_ID, GPIO2_PIR_3_INV_ID, //pulldown
  // Link/Status led
  // Phase out link leds, it will default to led1
  // GPIO2_LEDLNK_ID, GPIO2_LEDLNK_INV_ID,     // Inverted link led
  // Arilux RF Receive input
  GPIO2_ARIRFRCV_ID, GPIO2_ARIRFSEL_ID,
  // Buzzer
  GPIO2_BUZZER_ID, GPIO2_BUZZER_INV_ID,
  // GPS Serial
  GPIO2_GPS_NMEA_RX_ID, GPIO2_GPS_NMEA_TX_ID,
  // Basic IO for door closed/lock position
  GPIO2_DOOR_LOCK_ID, GPIO2_DOOR_OPEN_ID,
  // Nextion Touch panels 
  GPIO2_NEXTION_RX_ID, GPIO2_NEXTION_TX_ID, GPIO2_BACKLIGHT_ID,      // Display backlight control
  GPIO2_NEXTION_RX2_ID, GPIO2_NEXTION_TX2_ID,      // Serial2 for Nextion
  // Door bell chime (basic relay controls) - // Should be replaced as switch maybe?
  GPIO2_CHIME_INPUT_ID, GPIO2_CHIME_RINGER_ID,   // Relay silenoid
  // L9110 chip H-brige motor driver
  GPIO2_HBRIDGE_L9110_IA_ID, GPIO2_HBRIDGE_L9110_IB_ID, GPIO2_HBRIDGE_L9110_OA_ID, GPIO2_HBRIDGE_L9110_OB_ID, //GPIO2_HBRIDGE_ANALOG_SENSE_ID, //analog pin to use for sensing   //change to use anolog sensor class that updates automatically
  // Analog measuring types
  GPIO2_ANALOG_POSITION_ID,
  // PC Fan controls using PWM
  GPIO2_FAN_PWM1_ID,
  // Shelly 2.5 Energy Sensor with I2C
  GPIO2_ADE7953_IRQ_ID,
  // Shelly Dimmer 2 MCU
  GPIO2_SHELLY2_SHD_BOOT0_ID, GPIO2_SHELLY2_SHD_RESET_INV_ID,
  // ADC options
  GPIO2_ADC0_TEMPERATURE_ID,

  GPIO2_PULSE_COUNTER_ID,         // 
  GPIO2_FAN_IRSEND_ID,        // Calls ceiling fan class to use IR sender

  // Displays
  GPIO2_OLED_RESET_ID,


  /**
   * Analog Pins esp32
   * Adding GPIO number here, as ADC number is tied with physical gpio number (not mux'ed)
   * */
  GPIO2_ADC1_CH4_ID,
  GPIO2_ADC1_CH6_ID,
  GPIO2_ADC1_CH7_ID,
  GPIO2_ADC1_EXTERNAL_INTERRUPT_TRIGGER_ID,

  #ifdef ENABLE_DEVFEATURE_SWITCH_TO_U16_GPIO2_FUNCTIONS
  /**
   * Special cases
   * */
  GPIO2_FUNCTION_RXON_SAMPLING_ENABLED_ID,
  GPIO2_FUNCTION_CC1110_SYNC_PULSE_SIGNAL_ID,

  /**
   * @brief Fona Cellular
   **/
  GPIO2_FUNCTION__FONA_POWER_KEY__ID,
  GPIO2_FUNCTION__FONA_POWER_STATUS__ID,
  GPIO2_FUNCTION__FONA_NETWORK_STATUS__ID,
  GPIO2_FUNCTION__FONA_RESET__ID,
  GPIO2_FUNCTION__FONA_UART_TX__ID,
  GPIO2_FUNCTION__FONA_UART_RX__ID,
  GPIO2_FUNCTION__FONA_RING_INDICATOR__ID,
  #endif // ENABLE_DEVFEATURE_SWITCH_TO_U16_GPIO2_FUNCTIONS

  

  GPIO2_FUNCTION__MODEM_DATA_TERMINAL_READY_DTR__ID,
  GPIO2_FUNCTION__MODEM_TX__ID,
  GPIO2_FUNCTION__MODEM_RX__ID,
  GPIO2_FUNCTION__MODEM_POWER__ID,



  /**
   * @note All esp32 only options below this point
   * */
  // Webcamera
  GPIO2_WEBCAM_XCLK_ID,     // 0       (I)O                GPIO0, CAM_XCLK
  GPIO2_WEBCAM_DATA1_ID, GPIO2_WEBCAM_DATA2_ID, GPIO2_WEBCAM_DATA3_ID, GPIO2_WEBCAM_DATA4_ID, GPIO2_WEBCAM_DATA5_ID, GPIO2_WEBCAM_DATA6_ID, GPIO2_WEBCAM_DATA7_ID, GPIO2_WEBCAM_DATA8_ID,  // 35      I   NO PULLUP       GPIO35, CAM_DATA8
  GPIO2_WEBCAM_PCLK_ID,     // 22      IO      LED         GPIO22, CAM_PCLK
  GPIO2_WEBCAM_HREF_ID,     // 23      IO                  GPIO23, CAM_HREF
  GPIO2_WEBCAM_VSYNC_ID,    // 25      IO                  GPIO25, CAM_VSYNC
  GPIO2_WEBCAM_SIOD_ID,     // 26      IO                  GPIO26, CAM_SIOD
  GPIO2_WEBCAM_SIOC_ID,     // 27      IO                  GPIO27, CAM_SIOC
  GPIO2_WEBCAM_PWDN_ID,     // 32      IO                  GPIO32, CAM_PWDN
  GPIO2_WEBCAM_RESET_ID,

  #ifdef ENABLE_DEVFEATURE_SWITCH_TO_U16_GPIO2_FUNCTIONS
  // GPS Serial1 and 2 available on esp32 (2 of 3 ports)
  GPIO2_GPS_SERIAL1_TX_ID, GPIO2_GPS_SERIAL1_RX_ID,
  GPIO2_GPS_SERIAL2_TX_ID, GPIO2_GPS_SERIAL2_RX_ID,
  /**
   * SD Cards
   * */
  GPIO2_FUNCTION_SDCARD_VSPI_CSO_ID, GPIO2_FUNCTION_SDCARD_VSPI_CLK_ID, 
  GPIO2_FUNCTION_SDCARD_VSPI_MOSI_ID, GPIO2_FUNCTION_SDCARD_VSPI_MISO_ID,
  
  GPIO2_FUNCTION_SDCARD_HSPI_CSO_ID, GPIO2_FUNCTION_SDCARD_HSPI_CLK_ID, 
  GPIO2_FUNCTION_SDCARD_HSPI_MOSI_ID, GPIO2_FUNCTION_SDCARD_HSPI_MISO_ID,
  #endif // ENABLE_DEVFEATURE_SWITCH_TO_U16_GPIO2_FUNCTIONS
  
  GPIO2_SENSOR_END_ID 
}; // used 171of 250

/**
 * @brief Programmer selectable GPIO functionality
 */
enum ProgramSelectablePins2 {
  GPIO2_FIX_START_ID = 251,
  GPIO2_SPI_MISO_ID,       // SPI MISO library fixed pin GPIO12
  GPIO2_SPI_MOSI_ID,       // SPI MOSI library fixed pin GPIO13
  GPIO2_SPI_CLK_ID,        // SPI Clk library fixed pin GPIO14
  GPIO2_USER_ID=9999,           // User configurable needs to be 255
  GPIO2_MAX_ID };



  
// Friendly names of gpio functions (add ifdefs later)

DEFINE_PGM_CTR(PM_GPIO_FUNCTION_NONE_CTR)              D_GPIO_FUNCTION_NONE_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_UNUSED_FORCED_LOW_CTR)         D_GPIO_FUNCTION_UNUSED_FORCED_LOW_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_UNUSED_FORCED_HIGH_CTR)        D_GPIO_FUNCTION_UNUSED_FORCED_HIGH_CTR;



// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_ANALOG_CTR)      D_GPIO_FUNCTION_ANALOG_CTR;


// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_DHT11_1_CTR)           D_GPIO_FUNCTION_DHT11_1_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_DHT11_2_CTR)           D_GPIO_FUNCTION_DHT11_2_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_DHT22_1_CTR)           D_GPIO_FUNCTION_DHT22_1_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_DHT22_2_CTR)           D_GPIO_FUNCTION_DHT22_2_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_AM2301_1_CTR)          D_GPIO_FUNCTION_AM2301_CTR "_1";
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_AM2301_2_CTR)          D_GPIO_FUNCTION_AM2301_CTR "_2";


// #ifdef USE_I2C
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_I2C_SCL_CTR)           D_GPIO_FUNCTION_I2C_SCL_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_I2C_SDA_CTR)           D_GPIO_FUNCTION_I2C_SDA_CTR;
// #endif

// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_LDR_BASIC_DIGITAL1_CTR)     D_GPIO_FUNCTION_LDR_BASIC_DIGITAL1_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_LDR_BASIC_ANALOG1_CTR)      D_GPIO_FUNCTION_LDR_BASIC_ANALOG1_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_LDR_BASIC_DIGITAL2_CTR)     D_GPIO_FUNCTION_LDR_BASIC_DIGITAL2_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_LDR_BASIC_ANALOG2_CTR)      D_GPIO_FUNCTION_LDR_BASIC_ANALOG2_CTR;




#if defined(USE_MODULE_DISPLAYS_OLED_SH1106) || defined(USE_MODULE_DISPLAYS_OLED_SSD1306)
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_OLED_RESET_CTR)           D_GPIO_FUNCTION_OLED_RESET_CTR;
#endif

// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_RGB_DATA_CTR)          D_GPIO_FUNCTION_RGB_DATA_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_RGB_DATA1_CTR)          D_GPIO_FUNCTION_RGB_DATA1_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_RGB_CLOCK_CTR)         D_GPIO_FUNCTION_RGB_CLOCK_CTR;



// // #ifdef USE_MODULE_SENSORS_MOTION
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_PIR_1_CTR)             D_GPIO_FUNCTION_PIR_1_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_PIR_2_CTR)             D_GPIO_FUNCTION_PIR_2_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_PIR_3_CTR)             D_GPIO_FUNCTION_PIR_3_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_PIR_1_INV_CTR)         D_GPIO_FUNCTION_PIR_1_INV_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_PIR_2_INV_CTR)         D_GPIO_FUNCTION_PIR_2_INV_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_PIR_3_INV_CTR)         D_GPIO_FUNCTION_PIR_3_INV_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_PIR_1_NP_CTR)          D_GPIO_FUNCTION_PIR_1_NP_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_PIR_2_NP_CTR)          D_GPIO_FUNCTION_PIR_2_NP_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_PIR_3_NP_CTR)          D_GPIO_FUNCTION_PIR_3_NP_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_PIR_1_NP_INV_CTR)          D_GPIO_FUNCTION_PIR_1_NP_INV_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_PIR_2_NP_INV_CTR)          D_GPIO_FUNCTION_PIR_2_NP_INV_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_PIR_3_NP_INV_CTR)          D_GPIO_FUNCTION_PIR_3_NP_INV_CTR;
// // #endif
// // #ifdef USE_MODULE_SENSORS_DOOR
// // DEFINE_PGM_CTR(PM_GPIO_FUNCTION_DOOR_DETECT_CTR)       D_GPIO_FUNCTION_DOOR_DETECT_CTR;
// // #endif


// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_BUZZER_CTR) D_GPIO_FUNCTION_BUZZER_CTR;

#ifdef USE_MODULE_CONTROLLER_DOORCHIME
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_CHIME_INPUT_CTR)       D_GPIO_FUNCTION_CHIME_INPUT_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_CHIME_RINGER_CTR)      D_GPIO_FUNCTION_CHIME_RINGER_CTR;
#endif

// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_IRSEND_CTR)            D_GPIO_FUNCTION_IRSEND_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_FAN_IRSEND_CTR)        D_GPIO_FUNCTION_FAN_IRSEND_CTR;


#ifdef USE_MODULE_DRIVERS_RELAY
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_REL1_CTR)          D_GPIO_FUNCTION_REL1_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_REL2_CTR)          D_GPIO_FUNCTION_REL2_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_REL3_CTR)          D_GPIO_FUNCTION_REL3_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_REL4_CTR)          D_GPIO_FUNCTION_REL4_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_REL1_INV_CTR)          D_GPIO_FUNCTION_REL1_INV_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_REL2_INV_CTR)          D_GPIO_FUNCTION_REL2_INV_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_REL3_INV_CTR)          D_GPIO_FUNCTION_REL3_INV_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_REL4_INV_CTR)          D_GPIO_FUNCTION_REL4_INV_CTR;
#endif 

// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_FAN_PWM1_CTR)          D_GPIO_FUNCTION_FAN_PWM1_CTR;

// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_PWM1_CTR)          D_GPIO_FUNCTION_PWM1_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_PWM2_CTR)          D_GPIO_FUNCTION_PWM2_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_PWM3_CTR)          D_GPIO_FUNCTION_PWM3_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_PWM4_CTR)          D_GPIO_FUNCTION_PWM4_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_PWM5_CTR)          D_GPIO_FUNCTION_PWM5_CTR;

// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_PWM1_INV_CTR)          D_GPIO_FUNCTION_PWM1_INV_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_PWM2_INV_CTR)          D_GPIO_FUNCTION_PWM2_INV_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_PWM3_INV_CTR)          D_GPIO_FUNCTION_PWM3_INV_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_PWM4_INV_CTR)          D_GPIO_FUNCTION_PWM4_INV_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_PWM5_INV_CTR)          D_GPIO_FUNCTION_PWM5_INV_CTR;


#ifdef ESP32
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_HWSERIAL1_RING_BUFFER_TX_CTR) D_GPIO_FUNCTION_HWSERIAL1_RING_BUFFER_TX_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_HWSERIAL1_RING_BUFFER_RX_CTR) D_GPIO_FUNCTION_HWSERIAL1_RING_BUFFER_RX_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_HWSERIAL2_RING_BUFFER_TX_CTR) D_GPIO_FUNCTION_HWSERIAL2_RING_BUFFER_TX_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_HWSERIAL2_RING_BUFFER_RX_CTR) D_GPIO_FUNCTION_HWSERIAL2_RING_BUFFER_RX_CTR;
#endif

#ifdef ESP32
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_HWSERIAL0_TX_CTR)   D_GPIO_FUNCTION_HWSERIAL0_TX_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_HWSERIAL0_RX_CTR)   D_GPIO_FUNCTION_HWSERIAL0_RX_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_HWSERIAL1_TX_CTR)   D_GPIO_FUNCTION_HWSERIAL1_TX_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_HWSERIAL1_RX_CTR)   D_GPIO_FUNCTION_HWSERIAL1_RX_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_HWSERIAL2_TX_CTR)   D_GPIO_FUNCTION_HWSERIAL2_TX_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_HWSERIAL2_RX_CTR)   D_GPIO_FUNCTION_HWSERIAL2_RX_CTR;
#endif


// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_DEBUG_PIN1_CTR) D_GPIO_FUNCTION_DEBUG_PIN1_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_DEBUG_PIN2_CTR) D_GPIO_FUNCTION_DEBUG_PIN2_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_DEBUG_PIN3_CTR) D_GPIO_FUNCTION_DEBUG_PIN3_CTR;

// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_GPS_SERIAL0_TX_CTR)   D_GPIO_FUNCTION_GPS_SERIAL0_TX_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_GPS_SERIAL0_RX_CTR)   D_GPIO_FUNCTION_GPS_SERIAL0_RX_CTR;

#ifdef ESP32
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_GPS_SERIAL1_TX_CTR)   D_GPIO_FUNCTION_GPS_SERIAL1_TX_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_GPS_SERIAL1_RX_CTR)   D_GPIO_FUNCTION_GPS_SERIAL1_RX_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_GPS_SERIAL2_TX_CTR)   D_GPIO_FUNCTION_GPS_SERIAL2_TX_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_GPS_SERIAL2_RX_CTR)   D_GPIO_FUNCTION_GPS_SERIAL2_RX_CTR;
#endif // ESP32


#ifdef USE_MODULE_DRIVERS_LEDS
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_LEDLNK_CTR)         D_GPIO_FUNCTION_LEDLNK_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_LEDLNK_INV_CTR)         D_GPIO_FUNCTION_LED1_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_LED1_CTR)          D_GPIO_FUNCTION_LED1_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_LED2_CTR)          D_GPIO_FUNCTION_LED2_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_LED3_CTR)          D_GPIO_FUNCTION_LED3_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_LED4_CTR)          D_GPIO_FUNCTION_LED4_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_LED5_CTR)          D_GPIO_FUNCTION_LED5_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_LED1_INV_CTR)     D_GPIO_FUNCTION_LED1_INV_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_LED2_INV_CTR)     D_GPIO_FUNCTION_LED2_INV_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_LED3_INV_CTR)     D_GPIO_FUNCTION_LED3_INV_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_LED4_INV_CTR)     D_GPIO_FUNCTION_LED4_INV_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_LED5_INV_CTR)     D_GPIO_FUNCTION_LED5_INV_CTR;
#endif


#ifdef USE_MODULE_ENERGY_PZEM004T_V3
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_PZEM0XX_TX_CTR)     D_GPIO_FUNCTION_PZEM0XX_TX_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_PZEM0XX_MODBUS__RX_CTR)     D_GPIO_FUNCTION_PZEM0XX_RX_MODBUS_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_PZEM004_RX_CTR)     D_GPIO_FUNCTION_PZEM004_RX_CTR;
#endif

// // #ifdef USE_MODULE_SENSORS_ULTRASONICS
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SR04_ECHO_CTR)     D_GPIO_FUNCTION_SR04_ECHO_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SR04_TRIG_CTR)     D_GPIO_FUNCTION_SR04_TRIG_CTR;
// // #endif

// // #ifdef USE_MODULE_SENSORS_ULTRASONICS
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION__ROTARY_ENCODER_A__CTR)     D_GPIO_FUNCTION__ROTARY_ENCODER_A__CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION__ROTARY_ENCODER_B__CTR)     D_GPIO_FUNCTION__ROTARY_ENCODER_B__CTR;
// // #endif


/******************************************************************************************************************
 * Network
*******************************************************************************************************************/

/******************************************************************************************************************
 * Drivers
*******************************************************************************************************************/

/******************************************************************************************************************
 * Sensors
*******************************************************************************************************************/

#ifdef USE_MODULE_SENSORS_SWITCHES
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SWT1_CTR)         D_GPIO_FUNCTION_SWT1_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SWT2_CTR)         D_GPIO_FUNCTION_SWT2_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SWT3_CTR)         D_GPIO_FUNCTION_SWT3_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SWT4_CTR)         D_GPIO_FUNCTION_SWT3_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SWT5_CTR)         D_GPIO_FUNCTION_SWT4_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SWT6_CTR)         D_GPIO_FUNCTION_SWT5_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SWT7_CTR)         D_GPIO_FUNCTION_SWT6_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SWT8_CTR)         D_GPIO_FUNCTION_SWT7_CTR;

DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SWT1_INV_CTR)         D_GPIO_FUNCTION_SWT1_INV_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SWT2_INV_CTR)         D_GPIO_FUNCTION_SWT2_INV_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SWT3_INV_CTR)         D_GPIO_FUNCTION_SWT3_INV_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SWT4_INV_CTR)         D_GPIO_FUNCTION_SWT4_INV_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SWT5_INV_CTR)         D_GPIO_FUNCTION_SWT5_INV_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SWT6_INV_CTR)         D_GPIO_FUNCTION_SWT6_INV_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SWT7_INV_CTR)         D_GPIO_FUNCTION_SWT7_INV_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SWT8_INV_CTR)         D_GPIO_FUNCTION_SWT8_INV_CTR;

DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SWT1_NP_CTR)         D_GPIO_FUNCTION_SWT1_NP_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SWT2_NP_CTR)         D_GPIO_FUNCTION_SWT2_NP_CTR;
#endif // USE_MODULE_SENSORS_SWITCHES

#ifdef USE_MODULE_SENSORS__DS18X20_ESP32_2023
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_DS18X20_1_CTR)         D_GPIO_FUNCTION_DS18X20_1_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_DS18X20_2_CTR)         D_GPIO_FUNCTION_DS18X20_2_CTR;
#endif

#ifdef USE_MODULE_SENSORS_DOOR
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_DOOR_OPEN_CTR)           D_GPIO_FUNCTION_DOOR_OPEN_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_DOOR_LOCK_CTR)           D_GPIO_FUNCTION_DOOR_LOCK_CTR;
#endif

/******************************************************************************************************************
 * Lights
*******************************************************************************************************************/

/******************************************************************************************************************
 * Energy
*******************************************************************************************************************/

#ifdef USE_MODULE_ENERGY_ADE7953
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_ADE7953_IRQ_CTR)  D_GPIO_FUNCTION_ADE7953_IRQ_CTR;
#endif



/******************************************************************************************************************
 * Displays
*******************************************************************************************************************/
#ifdef USE_MODULE_DISPLAYS_NEXTION
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_NEXTION_TX_CTR)     D_GPIO_FUNCTION_NEXTION_TX_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_NEXTION_RX_CTR)     D_GPIO_FUNCTION_NEXTION_RX_CTR;
#endif // USE_MODULE_DISPLAYS_NEXTION

// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_KEY1_CTR)      D_GPIO_FUNCTION_KEY1_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_KEY2_CTR)      D_GPIO_FUNCTION_KEY2_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_KEY3_CTR)      D_GPIO_FUNCTION_KEY3_CTR;




// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_KEY1_INV_CTR)      D_GPIO_FUNCTION_KEY1_INV_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_KEY2_INV_CTR)      D_GPIO_FUNCTION_KEY2_INV_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_KEY3_INV_CTR)      D_GPIO_FUNCTION_KEY3_INV_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_KEY4_INV_CTR)      D_GPIO_FUNCTION_KEY4_INV_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_KEY5_INV_CTR)      D_GPIO_FUNCTION_KEY5_INV_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_KEY6_INV_CTR)      D_GPIO_FUNCTION_KEY6_INV_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_KEY7_INV_CTR)      D_GPIO_FUNCTION_KEY7_INV_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_KEY8_INV_CTR)      D_GPIO_FUNCTION_KEY8_INV_CTR;


// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_KEY1_NP_CTR)      D_GPIO_FUNCTION_KEY1_NP_CTR;

// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_KEY1_PULLDOWN_CTR)      D_GPIO_FUNCTION_KEY1_PULLDOWN_CTR;


// DEFINE_PGM_CTR(PM_GPIO_FUNCTION__RF_433MHZ_RX__CTR)      D_GPIO_FUNCTION__RF_433MHZ_RX__CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION__RF_433MHZ_TX__CTR)      D_GPIO_FUNCTION__RF_433MHZ_TX__CTR;



// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SERIAL_DEBUG_TX_CTR)  D_GPIO_FUNCTION_SERIAL_DEBUG_TX_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SERIAL_DEBUG_RX_CTR)  D_GPIO_FUNCTION_SERIAL_DEBUG_RX_CTR;

// DEFINE_PGM_CTR(PM_GPIO_FUNCTION__FONA_POWER_KEY__CTR)       D_GPIO_FUNCTION__FONA_POWER_KEY__CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION__FONA_POWER_STATUS__CTR)    D_GPIO_FUNCTION__FONA_POWER_STATUS__CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION__FONA_NETWORK_STATUS__CTR)  D_GPIO_FUNCTION__FONA_NETWORK_STATUS__CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION__FONA_RESET__CTR)           D_GPIO_FUNCTION__FONA_RESET__CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION__FONA_UART_TX__CTR)         D_GPIO_FUNCTION__FONA_UART_TX__CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION__FONA_UART_RX__CTR)         D_GPIO_FUNCTION__FONA_UART_RX__CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION__FONA_RING_INDICATOR__CTR)  D_GPIO_FUNCTION__FONA_RING_INDICATOR__CTR;

// DEFINE_PGM_CTR(PM_GPIO_FUNCTION__MODEM_DATA_TERMINAL_READY_DTR__CTR)           D_GPIO_FUNCTION__MODEM_DATA_TERMINAL_READY_DTR__CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION__MODEM_TX__CTR)         D_GPIO_FUNCTION__MODEM_TX__CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION__MODEM_RX__CTR)         D_GPIO_FUNCTION__MODEM_RX__CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION__MODEM_POWER__CTR)  D_GPIO_FUNCTION__MODEM_POWER__CTR;




// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_HBRIDGE_L9110_IA_CTR) D_GPIO_FUNCTION_HBRIDGE_L9110_IA_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_HBRIDGE_L9110_IB_CTR) D_GPIO_FUNCTION_HBRIDGE_L9110_IB_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_HBRIDGE_L9110_OA_CTR) D_GPIO_FUNCTION_HBRIDGE_L9110_OA_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_HBRIDGE_L9110_OB_CTR) D_GPIO_FUNCTION_HBRIDGE_L9110_OB_CTR;

// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_ANALOG_POSITION_CTR) D_GPIO_FUNCTION_ANALOG_POSITION_CTR;

#ifdef ESP32

DEFINE_PGM_CTR(PM_GPIO_FUNCTION_ADC1_CH4_CTR) D_GPIO_FUNCTION_ADC1_CH4_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_ADC1_CH6_CTR) D_GPIO_FUNCTION_ADC1_CH6_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_ADC1_CH7_CTR) D_GPIO_FUNCTION_ADC1_CH7_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_EXTERNAL_INTERRUPT_TRIGGER_CTR) D_GPIO_FUNCTION_EXTERNAL_INTERRUPT_TRIGGER_CTR;


DEFINE_PGM_CTR(PM_GPIO_FUNCTION_RXON_SAMPLING_ENABLED_CTR)   D_GPIO_FUNCTION_RXON_SAMPLING_ENABLED_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_CC1110_SYNC_PULSE_SIGNAL_CTR)   D_GPIO_FUNCTION_CC1110_SYNC_PULSE_SIGNAL_CTR;



  DEFINE_PGM_CTR(PM_GPIO_FUNCTION_WEBCAM_XCLK_CTR)            D_GPIO_WEBCAM_XCLK_CTR;
  DEFINE_PGM_CTR(PM_GPIO_FUNCTION_WEBCAM_DATA1_CTR)            D_GPIO_WEBCAM_DATA1_CTR;
  DEFINE_PGM_CTR(PM_GPIO_FUNCTION_WEBCAM_DATA2_CTR)            D_GPIO_WEBCAM_DATA2_CTR;
  DEFINE_PGM_CTR(PM_GPIO_FUNCTION_WEBCAM_DATA3_CTR)            D_GPIO_WEBCAM_DATA3_CTR;
  DEFINE_PGM_CTR(PM_GPIO_FUNCTION_WEBCAM_DATA4_CTR)            D_GPIO_WEBCAM_DATA4_CTR;
  DEFINE_PGM_CTR(PM_GPIO_FUNCTION_WEBCAM_DATA5_CTR)            D_GPIO_WEBCAM_DATA5_CTR;
  DEFINE_PGM_CTR(PM_GPIO_FUNCTION_WEBCAM_DATA6_CTR)           D_GPIO_WEBCAM_DATA6_CTR;
  DEFINE_PGM_CTR(PM_GPIO_FUNCTION_WEBCAM_DATA7_CTR)            D_GPIO_WEBCAM_DATA7_CTR;
  DEFINE_PGM_CTR(PM_GPIO_FUNCTION_WEBCAM_DATA8_CTR)            D_GPIO_WEBCAM_DATA8_CTR;
  DEFINE_PGM_CTR(PM_GPIO_FUNCTION_WEBCAM_PCLK_CTR)            D_GPIO_WEBCAM_PCLK_CTR;
  DEFINE_PGM_CTR(PM_GPIO_FUNCTION_WEBCAM_HREF_CTR)            D_GPIO_WEBCAM_HREF_CTR;
  DEFINE_PGM_CTR(PM_GPIO_FUNCTION_WEBCAM_VSYNC_CTR)            D_GPIO_WEBCAM_VSYNC_CTR;
  DEFINE_PGM_CTR(PM_GPIO_FUNCTION_WEBCAM_SIOD_CTR)            D_GPIO_WEBCAM_SIOD_CTR;
  DEFINE_PGM_CTR(PM_GPIO_FUNCTION_WEBCAM_SIOC_CTR)            D_GPIO_WEBCAM_SIOC_CTR;
  DEFINE_PGM_CTR(PM_GPIO_FUNCTION_WEBCAM_PWDN_CTR)            D_GPIO_WEBCAM_PWDN_CTR;

  DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SDCARD_VSPI_CSO_CTR)   D_GPIO_FUNCTION_SDCARD_VSPI_CSO_CTR;
  DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SDCARD_VSPI_CLK_CTR)   D_GPIO_FUNCTION_SDCARD_VSPI_CLK_CTR;
  DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SDCARD_VSPI_MOSI_CTR)  D_GPIO_FUNCTION_SDCARD_VSPI_MOSI_CTR;
  DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SDCARD_VSPI_MISO_CTR)  D_GPIO_FUNCTION_SDCARD_VSPI_MISO_CTR;

  DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SDCARD_HSPI_CSO_CTR)   D_GPIO_FUNCTION_SDCARD_HSPI_CSO_CTR;
  DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SDCARD_HSPI_CLK_CTR)   D_GPIO_FUNCTION_SDCARD_HSPI_CLK_CTR;
  DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SDCARD_HSPI_MOSI_CTR)  D_GPIO_FUNCTION_SDCARD_HSPI_MOSI_CTR;
  DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SDCARD_HSPI_MISO_CTR)  D_GPIO_FUNCTION_SDCARD_HSPI_MISO_CTR;

#endif



/**********MODULE CONFIG**********************************************************************************/
/**********MODULE CONFIG**********************************************************************************/
/**********MODULE CONFIG**********************************************************************************/
/**********MODULE CONFIG**********************************************************************************/
/**********MODULE CONFIG**********************************************************************************/
/**********MODULE CONFIG**********************************************************************************/
/**********MODULE CONFIG**********************************************************************************/
/**********MODULE CONFIG**********************************************************************************/

// Create ifdefs to include certain module templates
#define USE_MODULE_TEMPLATE_SONOFF_BASIC
#define USE_MODULE_TEMPLATE_SONOFF_BASIC_EXTERNAL
#define USE_MODULE_TEMPLATE_H801
#define USE_MODULE_TEMPLATE_MAGICHOME
#define USE_MODULE_TEMPLATE_SHELLY1
#define USE_MODULE_TEMPLATE_SHELLY_2P5
#define USE_MODULE_TEMPLATE_SHELLY_DIMMER2

#define USE_MODULE_TEMPLATE_DEFAULT_WEMOS
#define USE_MODULE_TEMPLATE_SONOFF_IFAN03
#define USE_MODULE_TEMPLATE_SONOFF_4CHPRO

// Supported hardware modules. Leave completed list
enum SupportedModules_8266_StaticCompleteList {
  MODULE_WEMOS_ID,    //should be renamed as generic so esp32/esp8266 can fallback this
  MODULE_SONOFF_BASIC_ID,
  MODULE_SONOFF_BASIC_EXTERNAL_ID, // tmp solution until both fixed modules can also have extra gpio added on top of default templates eg adding key2 to basic
  MODULE_H801_ID,
  MODULE_MAGICHOME_ID,
  MODULE_SHELLY1_ID,
  MODULE_SHELLY2P5_ID,
  MODULE_SHELLY_DIMMER2_ID,
  #ifdef USE_MODULE_TEMPLATE_SONOFF_IFAN03 // I probably dont want these here, to keep this list the same, but array method below is wrong with it
  MODULE_SONOFF_IFAN03_ID,
  #endif // USE_MODULE_TEMPLATE_SONOFF_IFAN03
  MODULE_SONOFF_4CHPRO_ID,
  // Last module
  MODULE_MAXMODULE_8266 // moved to dynamic ID list so it allows changing array size
};




  // #define            D_MODULE_NAME_GENERIC_CTR            "Generic"
  // DEFINE_PGM_CTR(PM_MODULE_NAME_GENERIC_CTR)          D_MODULE_NAME_GENERIC_CTR;

  // #define            D_MODULE_NAME_NODEMCU_CTR            "NodeMCU"
  DEFINE_PGM_CTR(PM_MODULE_NAME_NODEMCU_CTR)          D_MODULE_NAME_NODEMCU_CTR;

  // #define            D_MODULE_NAME_USERMODULE_CTR            "User Module" // The new "Generic"
  DEFINE_PGM_CTR(PM_MODULE_NAME_USERMODULE_CTR)          D_MODULE_NAME_USERMODULE_CTR;

#ifdef USE_MODULE_TEMPLATE_SONOFF_BASIC
  // #define            D_MODULE_NAME_SONOFF_BASIC_CTR       "Sonoff Basic"
  DEFINE_PGM_CTR(PM_MODULE_NAME_SONOFF_BASIC_CTR)     D_MODULE_NAME_SONOFF_BASIC_CTR;
#endif
#ifdef USE_MODULE_TEMPLATE_SONOFF_BASIC_EXTERNAL
  // #define            D_MODULE_NAME_SONOFF_BASIC_EXTERNAL_CTR       "Sonoff BasEx"
  DEFINE_PGM_CTR(PM_MODULE_NAME_SONOFF_BASIC_EXTERNAL_CTR)     D_MODULE_NAME_SONOFF_BASIC_EXTERNAL_CTR;
#endif
#ifdef USE_MODULE_TEMPLATE_H801
  // #define            D_MODULE_NAME_H801_CTR               "H801"
  DEFINE_PGM_CTR(PM_MODULE_NAME_H801_CTR)             D_MODULE_NAME_H801_CTR;
#endif
#ifdef USE_MODULE_TEMPLATE_MAGICHOME
  // #define            D_MODULE_NAME_MAGICHOME_CTR          "MagicHome"
  DEFINE_PGM_CTR(PM_MODULE_NAME_MAGICHOME_CTR)        D_MODULE_NAME_MAGICHOME_CTR;
#endif
#ifdef USE_MODULE_TEMPLATE_SHELLY1
  // #define            D_MODULE_NAME_SHELLY1_CTR       "Shelly 1"
  DEFINE_PGM_CTR(PM_MODULE_NAME_SHELLY1_CTR)     D_MODULE_NAME_SHELLY1_CTR;
#endif
#ifdef USE_MODULE_TEMPLATE_SHELLY_2P5
  // #define            D_MODULE_NAME_SHELLY2P5_CTR       "Shelly 2"
  DEFINE_PGM_CTR(PM_MODULE_NAME_SHELLY2P5_CTR)     D_MODULE_NAME_SHELLY2P5_CTR;
#endif
#ifdef USE_MODULE_TEMPLATE_SHELLY_DIMMER2
  // #define            D_MODULE_NAME_SHELLY_DIMMER2_CTR       "Shelly Dimmer 2"
  DEFINE_PGM_CTR(PM_MODULE_NAME_SHELLY_DIMMER2_CTR)     D_MODULE_NAME_SHELLY_DIMMER2_CTR;
#endif

#ifdef USE_MODULE_TEMPLATE_SONOFF_4CHPRO
  // #define            D_MODULE_NAME_SONOFF_4CHPRO_CTR       "Sonoff 4CHPRO"
  DEFINE_PGM_CTR(PM_MODULE_NAME_SONOFF_4CHPRO_CTR)     D_MODULE_NAME_SONOFF_4CHPRO_CTR;
#endif
#ifdef USE_MODULE_TEMPLATE_SONOFF_IFAN03
  // #define            D_MODULE_NAME_SONOFF_IFAN03_CTR       "Sonoff IFAN03"
  DEFINE_PGM_CTR(PM_MODULE_NAME_SONOFF_IFAN03_CTR)     D_MODULE_NAME_SONOFF_IFAN03_CTR;
#endif



/**
 * @brief Enum list defining all GPIO functions that is fixed, unique and non changing across builds and hardware
 * @note This list will always be created in its full form
 * @note INV = Inverted pin, low/ground is active
 * @note NP  = No pullup/down 
 * @note Never add `#ifdef` into this enum, as I want all GPIO to always exist and be static for long term debug. `ifdef` should be considered around nicelist
 * @note PD = Pulled down (hardware dependant)
 */
enum GPIO_COMPLETE_STATIC_LIST_IDS {
  // Default for unused
  GPIO_NONE_ID,
  GPIO_ANALOG_ID, // basic analog that any enabled modules can use on the esp8266, this will need changed to be numbers so esp8266 defaults to 1 and esp32 cna use them all

  // DHT11/22 pins (enabled auto detect?)
  GPIO_DHT11_1OF2_ID, GPIO_DHT11_2OF2_ID,
  // DHT22
  GPIO_DHT22_1OF2_ID, GPIO_DHT22_2OF2_ID,
  // DallasTemperaure 1-wire sensor
  GPIO_DSB_1OF2_ID, GPIO_DSB_2OF2_ID,
  // I2C
  GPIO_I2C_SCL_ID, GPIO_I2C_SDA_ID,

  // With IC connects that need to be set high/low when unused for stability eg level shifters
  GPIO_UNUSED_FORCED_HIGH_ID,
  GPIO_UNUSED_FORCED_LOW_ID,

  // // Addressable RGB(w) leds
  // GPIO_RGB_DATA_ID, GPIO_RGB_CLOCK_ID,
  // GPIO_RGB_DATA1_ID, GPIO_RGB_DATA2_ID, GPIO_RGB_DATA3_ID, GPIO_RGB_DATA4_ID,  // needs to be done in this order
  // GPIO_RGB_CLOCK1_ID, GPIO_RGB_CLOCK2_ID, GPIO_RGB_CLOCK3_ID, GPIO_RGB_CLOCK4_ID,
  
  // IR Transceiver
  GPIO_IRSEND_ID, GPIO_IRRECV_ID,
  // Switches = 8. User connected external switches (No longer using offset, making discrete options)
  GPIO_SWT1_ID,        GPIO_SWT2_ID,        GPIO_SWT3_ID, GPIO_SWT4_ID, GPIO_SWT5_ID, GPIO_SWT6_ID, GPIO_SWT7_ID, GPIO_SWT8_ID,
  GPIO_SWT1_INV_ID,    GPIO_SWT2_INV_ID,    GPIO_SWT3_INV_ID, GPIO_SWT4_INV_ID, GPIO_SWT5_INV_ID, GPIO_SWT6_INV_ID, GPIO_SWT7_INV_ID, GPIO_SWT8_INV_ID,
  GPIO_SWT1_NP_ID,     GPIO_SWT2_NP_ID,     GPIO_SWT3_NP_ID, GPIO_SWT4_NP_ID, GPIO_SWT5_NP_ID, GPIO_SWT6_NP_ID, GPIO_SWT7_NP_ID, GPIO_SWT8_NP_ID,
  GPIO_SWT1_INV_NP_ID, GPIO_SWT2_INV_NP_ID, GPIO_SWT3_INV_NP_ID, GPIO_SWT4_INV_NP_ID, GPIO_SWT5_INV_NP_ID, GPIO_SWT6_INV_NP_ID, GPIO_SWT7_INV_NP_ID, GPIO_SWT8_INV_NP_ID,
  // Buttons = 4 (rename keys to buttons)
  GPIO_KEY1_ID, GPIO_KEY2_ID, GPIO_KEY3_ID, GPIO_KEY4_ID, GPIO_KEY5_ID, GPIO_KEY6_ID, GPIO_KEY7_ID, GPIO_KEY8_ID,
  GPIO_KEY1_INV_ID, GPIO_KEY2_INV_ID, GPIO_KEY3_INV_ID, GPIO_KEY4_INV_ID, GPIO_KEY5_INV_ID, GPIO_KEY6_INV_ID, GPIO_KEY7_INV_ID, GPIO_KEY8_INV_ID,
  GPIO_KEY1_NP_ID, GPIO_KEY2_NP_ID, GPIO_KEY3_NP_ID, GPIO_KEY4_NP_ID, GPIO_KEY5_NP_ID, GPIO_KEY6_NP_ID, GPIO_KEY7_NP_ID, GPIO_KEY8_NP_ID, 
  GPIO_KEY1_INV_NP_ID, GPIO_KEY2_INV_NP_ID, GPIO_KEY3_INV_NP_ID, GPIO_KEY4_INV_NP_ID, GPIO_KEY5_INV_NP_ID, GPIO_KEY6_INV_NP_ID, GPIO_KEY7_INV_NP_ID, GPIO_KEY8_INV_NP_ID,
  //GPIO_KEY1_PULLDOWN_ID,GPIO_KEY2_PULLDOWN_ID,GPIO_KEY3_PULLDOWN_ID,GPIO_KEY4_PULLDOWN_ID,GPIO_KEY5_PULLDOWN_ID,GPIO_KEY6_PULLDOWN_ID,GPIO_KEY7_PULLDOWN_ID,GPIO_KEY8_PULLDOWN_ID, // only some buttons can be pulldown enabled
  //unknown button options?
  GPIO_CNTR1_ID, GPIO_CNTR2_ID, GPIO_CNTR3_ID, GPIO_CNTR4_ID,
  GPIO_CNTR1_NP_ID, GPIO_CNTR2_NP_ID, GPIO_CNTR3_NP_ID, GPIO_CNTR4_NP_ID,
  // Relays
  GPIO_REL1_ID, GPIO_REL2_ID, GPIO_REL3_ID, GPIO_REL4_ID, GPIO_REL5_ID, GPIO_REL6_ID, GPIO_REL7_ID, GPIO_REL8_ID,
  GPIO_REL1_INV_ID, GPIO_REL2_INV_ID, GPIO_REL3_INV_ID, GPIO_REL4_INV_ID, GPIO_REL5_INV_ID, GPIO_REL6_INV_ID, GPIO_REL7_INV_ID, GPIO_REL8_INV_ID,
  // PWM 2023: PWM Channels are no longer part of lighting
  GPIO_PWM1_ID, GPIO_PWM2_ID, GPIO_PWM3_ID, GPIO_PWM4_ID, GPIO_PWM5_ID,
  GPIO_PWM1_INV_ID, GPIO_PWM2_INV_ID, GPIO_PWM3_INV_ID, GPIO_PWM4_INV_ID, GPIO_PWM5_INV_ID,
  // LEDs
  GPIO_LED1_ID, GPIO_LED2_ID, GPIO_LED3_ID, GPIO_LED4_ID,
  GPIO_LED1_INV_ID, GPIO_LED2_INV_ID, GPIO_LED3_INV_ID, GPIO_LED4_INV_ID,
  // MH-Z19 Serial interface
  GPIO_MHZ_TXD_ID, GPIO_MHZ_RXD_ID,
  // SenseAir Serial interface
  GPIO_SAIR_TX_ID, GPIO_SAIR_RX_ID,
  // SPI Chip Select, SPI Data Direction
  GPIO_SPI_CS_ID, GPIO_SPI_DC_ID,
  // Serial Bridge Serial interface
  GPIO_SBR_TX_ID, GPIO_SBR_RX_ID,
  // SR04 ultrasonic
  GPIO_SR04_TRIG_ID, GPIO_SR04_ECHO_ID,
  // Rotary Encoder (e.g. LPD3806-360BM-G5-24C)
  GPIO__ROTARY_ENCODER_A__ID, GPIO__ROTARY_ENCODER_B__ID,
  // LDR Basic
  GPIO_LDR_BASIC_DIGITAL1_ID, GPIO_LDR_BASIC_ANALOG1_ID,
  GPIO_LDR_BASIC_DIGITAL2_ID, GPIO_LDR_BASIC_ANALOG2_ID,
  // SDMxx interfaces
  GPIO_SDM120_TX_ID, GPIO_SDM120_RX_ID, GPIO_SDM630_TX_ID, GPIO_SDM630_RX_ID,
  // PZEM0XX Serial interface, PZEM004T Serial interface, PZEM-014_ID,016 Serial Modbus interface, PZEM-003_ID,017 Serial Modbus interface 
  GPIO_PZEM0XX_TX_ID, GPIO_PZEM004_RX_ID, GPIO_PZEM0XX_RX_MODBUS_ID, GPIO_PZEM017_RX_ID,
  // HX711 Load Cell
  GPIO_HX711_SCK_ID, GPIO_HX711_DAT_ID,
  // RF Transceiver
  GPIO_RFSEND_ID, GPIO_RFRECV_ID,
  // Tuya Serial interface
  GPIO_TUYA_TX_ID, GPIO_TUYA_RX_ID,
  // Software SPI (Master Input Slave Output, Master Output Slave Input, Serial Clock, Chip Select, Data or Command)
  GPIO_SSPI_MISO_ID, GPIO_SSPI_MOSI_ID, GPIO_SSPI_SCLK_ID, GPIO_SSPI_CS_ID, GPIO_SSPI_DC_ID,
  // Energy monitor chip = MCP39F501 Serial interface (Shelly2)
  GPIO_MCP39F5_TX_ID, GPIO_MCP39F5_RX_ID, GPIO_MCP39F5_RST_ID,
  // CSE7766 Serial interface (S31 and Pow R2)
  GPIO_CSE7766_TX_ID, GPIO_CSE7766_RX_ID,
  // 433 MHz SAW Radio transceivers  
  GPIO_RF_433MHZ_RX_ID, GPIO_RF_433MHZ_TX_ID,
  // Serial pins (Auto detect hardware vs serial)
  // GPIO_SERIAL_TX_ID, GPIO_SERIAL_RX_ID, //phase out to more specific one below
  GPIO_HWSERIAL0_TX_ID, GPIO_HWSERIAL0_RX_ID,
  GPIO_HWSERIAL1_TX_ID, GPIO_HWSERIAL1_RX_ID,
  GPIO_HWSERIAL2_TX_ID, GPIO_HWSERIAL2_RX_ID,
  GPIO_SWSERIAL0_TX_ID, GPIO_SWSERIAL0_RX_ID,
  // RingBuffers are used on the receive data (PHASE OUT)
  GPIO_HWSERIAL0_RING_BUFFER_TX_ID, GPIO_HWSERIAL0_RING_BUFFER_RX_ID,       // RinfBuffer GPIO should be removed, and instead be a special mode of the serial class. Simply set TX/RX, then with another command enable ringbuffer when desired. 
  GPIO_HWSERIAL1_RING_BUFFER_TX_ID, GPIO_HWSERIAL1_RING_BUFFER_RX_ID,
  GPIO_HWSERIAL2_RING_BUFFER_TX_ID, GPIO_HWSERIAL2_RING_BUFFER_RX_ID,

  GPIO_SERIAL_DEBUG_TX_ID, GPIO_SERIAL_DEBUG_RX_ID,
  // GPS Serial0 on both esp devices (1 of 3)
  GPIO_GPS_SERIAL0_TX_ID, GPIO_GPS_SERIAL0_RX_ID,


  // /**
  //  * @brief MAVLink Decoder
  //  **/
  // GPIO_MAVLINK_DECODER_HWSERIAL0_TX_ID, GPIO_MAVLINK_DECODER_HWSERIAL0_RX_ID,
  // GPIO_MAVLINK_DECODER_HWSERIAL1_TX_ID, GPIO_MAVLINK_DECODER_HWSERIAL1_RX_ID,
  // GPIO_MAVLINK_DECODER_HWSERIAL2_TX_ID, GPIO_MAVLINK_DECODER_HWSERIAL2_RX_ID,
  // /**
  //  * @brief MAVLink Telemetry Passthrough
  //  **/
  // GPIO_MAVLINK_TELEMETRY_HWSERIAL0_TX_ID, GPIO_MAVLINK_TELEMETRY_HWSERIAL0_RX_ID,
  // GPIO_MAVLINK_TELEMETRY_HWSERIAL1_TX_ID, GPIO_MAVLINK_TELEMETRY_HWSERIAL1_RX_ID,
  // GPIO_MAVLINK_TELEMETRY_HWSERIAL2_TX_ID, GPIO_MAVLINK_TELEMETRY_HWSERIAL2_RX_ID,



  // Rotary switch
  GPIO_ROT1A_ID, GPIO_ROT1B_ID, GPIO_ROT2A_ID, GPIO_ROT2B_ID,
  // // PIR Motion 
  // GPIO_PIR_1_ID, GPIO_PIR_2_ID, GPIO_PIR_3_ID,         //pullup
  // GPIO_PIR_1_NP_ID, GPIO_PIR_2_NP_ID, GPIO_PIR_3_NP_ID,
  // GPIO_PIR_1_NP_INV_ID, GPIO_PIR_2_NP_INV_ID, GPIO_PIR_3_NP_INV_ID,
  // GPIO_PIR_1_INV_ID, GPIO_PIR_2_INV_ID, GPIO_PIR_3_INV_ID, //pulldown
  // Link/Status led
  // Phase out link leds, it will default to led1
  // GPIO_LEDLNK_ID, GPIO_LEDLNK_INV_ID,     // Inverted link led
  // Arilux RF Receive input
  GPIO_ARIRFRCV_ID, GPIO_ARIRFSEL_ID,
  // Buzzer
  GPIO_BUZZER_ID, GPIO_BUZZER_INV_ID,
  // GPS Serial
  GPIO_GPS_NMEA_RX_ID, GPIO_GPS_NMEA_TX_ID,
  // Basic IO for door closed/lock position
  GPIO_DOOR_LOCK_ID, GPIO_DOOR_OPEN_ID,
  // Nextion Touch panels 
  GPIO_NEXTION_RX_ID, GPIO_NEXTION_TX_ID, GPIO_BACKLIGHT_ID,      // Display backlight control
  GPIO_NEXTION_RX2_ID, GPIO_NEXTION_TX2_ID,      // Serial2 for Nextion
  // Door bell chime (basic relay controls) - // Should be replaced as switch maybe?
  GPIO_CHIME_INPUT_ID, GPIO_CHIME_RINGER_ID,   // Relay silenoid
  // L9110 chip H-brige motor driver
  GPIO_HBRIDGE_L9110_IA_ID, GPIO_HBRIDGE_L9110_IB_ID, GPIO_HBRIDGE_L9110_OA_ID, GPIO_HBRIDGE_L9110_OB_ID, //GPIO_HBRIDGE_ANALOG_SENSE_ID, //analog pin to use for sensing   //change to use anolog sensor class that updates automatically
  // Analog measuring types
  GPIO_ANALOG_POSITION_ID,
  // PC Fan controls using PWM
  GPIO_FAN_PWM1_ID,
  // Shelly 2.5 Energy Sensor with I2C
  GPIO_ADE7953_IRQ_ID,
  // Shelly Dimmer 2 MCU
  GPIO_SHELLY2_SHD_BOOT0_ID, GPIO_SHELLY2_SHD_RESET_INV_ID,
  // ADC options
  GPIO_ADC0_TEMPERATURE_ID,

  GPIO_PULSE_COUNTER_ID,         // 
  GPIO_FAN_IRSEND_ID,        // Calls ceiling fan class to use IR sender

  // Displays
  GPIO_OLED_RESET_ID,


  /**
   * Analog Pins esp32
   * Adding GPIO number here, as ADC number is tied with physical gpio number (not mux'ed)
   * */
  GPIO_ADC1_CH4_ID,
  GPIO_ADC1_CH6_ID,
  GPIO_ADC1_CH7_ID,
  GPIO_ADC1_EXTERNAL_INTERRUPT_TRIGGER_ID,

  /**
   * Special cases
   * */
  GPIO_FUNCTION_RXON_SAMPLING_ENABLED_ID,
  GPIO_FUNCTION_CC1110_SYNC_PULSE_SIGNAL_ID,

  /**
   * @brief Fona Cellular
   **/
  GPIO_FUNCTION__FONA_POWER_KEY__ID,
  GPIO_FUNCTION__FONA_POWER_STATUS__ID,
  GPIO_FUNCTION__FONA_NETWORK_STATUS__ID,
  GPIO_FUNCTION__FONA_RESET__ID,
  GPIO_FUNCTION__FONA_UART_TX__ID,
  GPIO_FUNCTION__FONA_UART_RX__ID,
  GPIO_FUNCTION__FONA_RING_INDICATOR__ID,

  

  GPIO_FUNCTION__MODEM_DATA_TERMINAL_READY_DTR__ID,
  GPIO_FUNCTION__MODEM_TX__ID,
  GPIO_FUNCTION__MODEM_RX__ID,
  GPIO_FUNCTION__MODEM_POWER__ID,



  /**
   * @note All esp32 only options below this point
   * */
  // Webcamera
  GPIO_WEBCAM_XCLK_ID,     // 0       (I)O                GPIO0, CAM_XCLK
  GPIO_WEBCAM_DATA1_ID, GPIO_WEBCAM_DATA2_ID, GPIO_WEBCAM_DATA3_ID, GPIO_WEBCAM_DATA4_ID, GPIO_WEBCAM_DATA5_ID, GPIO_WEBCAM_DATA6_ID, GPIO_WEBCAM_DATA7_ID, GPIO_WEBCAM_DATA8_ID,  // 35      I   NO PULLUP       GPIO35, CAM_DATA8
  GPIO_WEBCAM_PCLK_ID,     // 22      IO      LED         GPIO22, CAM_PCLK
  GPIO_WEBCAM_HREF_ID,     // 23      IO                  GPIO23, CAM_HREF
  GPIO_WEBCAM_VSYNC_ID,    // 25      IO                  GPIO25, CAM_VSYNC
  GPIO_WEBCAM_SIOD_ID,     // 26      IO                  GPIO26, CAM_SIOD
  GPIO_WEBCAM_SIOC_ID,     // 27      IO                  GPIO27, CAM_SIOC
  GPIO_WEBCAM_PWDN_ID,     // 32      IO                  GPIO32, CAM_PWDN
  GPIO_WEBCAM_RESET_ID,

  #ifdef USE_MODULE_DRIVERS_SDCARD
  // GPS Serial1 and 2 available on esp32 (2 of 3 ports)
  GPIO_GPS_SERIAL1_TX_ID, GPIO_GPS_SERIAL1_RX_ID,
  GPIO_GPS_SERIAL2_TX_ID, GPIO_GPS_SERIAL2_RX_ID,
  /**
   * SD Cards
   * */
  GPIO_FUNCTION_SDCARD_VSPI_CSO_ID, GPIO_FUNCTION_SDCARD_VSPI_CLK_ID, 
  GPIO_FUNCTION_SDCARD_VSPI_MOSI_ID, GPIO_FUNCTION_SDCARD_VSPI_MISO_ID,
  
  GPIO_FUNCTION_SDCARD_HSPI_CSO_ID, GPIO_FUNCTION_SDCARD_HSPI_CLK_ID, 
  GPIO_FUNCTION_SDCARD_HSPI_MOSI_ID, GPIO_FUNCTION_SDCARD_HSPI_MISO_ID,
  #endif // USE_MODULE_DRIVERS_SDCARD
  
  GPIO_SENSOR_END_ID 
}; // used 171of 250

/**
 * @brief Programmer selectable GPIO functionality
 */
enum ProgramSelectablePins {
  GPIO_FIX_START_ID = 251,
  GPIO_SPI_MISO_ID,       // SPI MISO library fixed pin GPIO12
  GPIO_SPI_MOSI_ID,       // SPI MOSI library fixed pin GPIO13
  GPIO_SPI_CLK_ID,        // SPI Clk library fixed pin GPIO14
  GPIO_USER_ID=9999,           // User configurable needs to be 255
  GPIO_MAX_ID };

/**
 * @brief Only the GPIOs that are enabled for this device (created from `GPIO_COMPLETE_STATIC_LIST_IDS`)
 */
const uint16_t kList_Selectable_Function_IDs[] PROGMEM = {
  GPIO_NONE_ID,           // Not used
  GPIO_KEY1_ID,           // Buttons
  GPIO_KEY1_NP_ID,
  GPIO_KEY1_INV_ID,
  GPIO_KEY1_INV_NP_ID,
  GPIO_KEY2_ID,
  GPIO_KEY2_NP_ID,
  GPIO_KEY2_INV_ID,
  GPIO_KEY2_INV_NP_ID,
  GPIO_KEY3_ID,
  GPIO_KEY3_NP_ID,
  GPIO_KEY3_INV_ID,
  GPIO_KEY3_INV_NP_ID,
  GPIO_KEY4_ID,
  GPIO_KEY4_NP_ID,
  GPIO_KEY4_INV_ID,
  GPIO_KEY4_INV_NP_ID,
  GPIO_SWT1_ID,           // User connected external switches
  GPIO_SWT1_NP_ID,
  GPIO_SWT2_ID,
  GPIO_SWT2_NP_ID,
  GPIO_SWT3_ID,
  GPIO_SWT3_NP_ID,
  GPIO_SWT4_ID,
  GPIO_SWT4_NP_ID,
  GPIO_SWT5_ID,
  GPIO_SWT5_NP_ID,
  GPIO_SWT6_ID,
  GPIO_SWT6_NP_ID,
  GPIO_SWT7_ID,
  GPIO_SWT7_NP_ID,
  GPIO_SWT8_ID,
  GPIO_SWT8_NP_ID,
  GPIO_REL1_ID,           // Relays
  GPIO_REL1_INV_ID,
  GPIO_REL2_ID,
  GPIO_REL2_INV_ID,
  GPIO_REL3_ID,
  GPIO_REL3_INV_ID,
  GPIO_REL4_ID,
  GPIO_REL4_INV_ID,
  GPIO_REL5_ID,
  GPIO_REL5_INV_ID,
  GPIO_REL6_ID,
  GPIO_REL6_INV_ID,
  GPIO_REL7_ID,
  GPIO_REL7_INV_ID,
  GPIO_REL8_ID,
  GPIO_REL8_INV_ID,
  GPIO_LED1_ID,           // Leds
  GPIO_LED1_INV_ID,
  GPIO_LED2_ID,
  GPIO_LED2_INV_ID,
  GPIO_LED3_ID,
  GPIO_LED3_INV_ID,
  GPIO_LED4_ID,
  GPIO_LED4_INV_ID,
  GPIO_PWM1_ID,           // RGB   Red   or C  Cold White
  GPIO_PWM1_INV_ID,
  GPIO_PWM2_ID,           // RGB   Green or CW Warm White
  GPIO_PWM2_INV_ID,
  GPIO_PWM3_ID,           // RGB   Blue
  GPIO_PWM3_INV_ID,
  GPIO_PWM4_ID,           // RGBW  (Cold) White
  GPIO_PWM4_INV_ID,
  GPIO_PWM5_ID,           // RGBCW Warm White
  GPIO_PWM5_INV_ID,
  GPIO_CNTR1_ID,          // Counters
  GPIO_CNTR1_NP_ID,
  GPIO_CNTR2_ID,
  GPIO_CNTR2_NP_ID,
  GPIO_CNTR3_ID,
  GPIO_CNTR3_NP_ID,
  GPIO_CNTR4_ID,
  GPIO_CNTR4_NP_ID,
  GPIO_HWSERIAL0_TX_ID,            // Serial interface
  GPIO_HWSERIAL0_RX_ID,            // Serial interface
  GPIO_HWSERIAL1_TX_ID,            // Serial interface
  GPIO_HWSERIAL1_RX_ID,            // Serial interface
  GPIO_HWSERIAL2_TX_ID,            // Serial interface
  GPIO_HWSERIAL2_RX_ID,            // Serial interface
  GPIO_SWSERIAL0_TX_ID,            // Serial interface
  GPIO_SWSERIAL0_RX_ID,            // Serial interface
#ifdef USE_I2C
  GPIO_I2C_SCL_ID,        // I2C SCL
  GPIO_I2C_SDA_ID,        // I2C SDA
#endif
#ifdef USE_SPI
  GPIO_SPI_CS_ID,         // SPI Chip Select
  GPIO_SPI_DC_ID,         // SPI Data Direction
  GPIO_SSPI_MISO_ID,      // Software SPI Master Input Slave Output
  GPIO_SSPI_MOSI_ID,      // Software SPI Master Output Slave Input
  GPIO_SSPI_SCLK_ID,      // Software SPI Serial Clock
  GPIO_SSPI_CS_ID,        // Software SPI Chip Select
  GPIO_SSPI_DC_ID,        // Software SPI Data or Command
#endif
#ifdef USE_DISPLAY
  GPIO_BACKLIGHT_ID,      // Display backlight control
#endif
#ifdef USE_MODULE_DRIVER_BUZZER
  GPIO_BUZZER_ID,         // Buzzer
  GPIO_BUZZER_INV_ID,     // Inverted buzzer
#endif
#ifdef USE_MODULE_SENSORS_DHT
  GPIO_DHT11_1OF2_ID,          // DHT11
  GPIO_DHT11_2OF2_ID,          // DHT11
  GPIO_DHT22_1OF2_ID,          // DHT21, DHT22, AM2301, AM2302, AM2321
  GPIO_DHT22_2OF2_ID,          // DHT21, DHT22, AM2301, AM2302, AM2321
#endif
//#if defined(USE_DS18B20) || defined(USE_DS18x20) || defined(USE_DS18x20_LEGACY)
  GPIO_DSB_1OF2_ID,            // Single wire DS18B20 or DS18S20
  GPIO_DSB_2OF2_ID,            // Single wire DS18B20 or DS18S20
//#endif
#ifdef USE_WS2812
  GPIO_RGB_DATA_ID,         // WS2812 Led string
  GPIO_RGB_CLOCK_ID,         // WS2812 Led string
#endif
#ifdef USE_IR_REMOTE
  GPIO_IRSEND_ID,         // IR remote
#ifdef USE_IR_RECEIVE
  GPIO_IRRECV_ID,         // IR receiver
#endif
#endif
#ifdef USE_RC_SWITCH
  GPIO_RFSEND_ID,         // RF transmitter
  GPIO_RFRECV_ID,         // RF receiver
#endif
// #ifdef USE_RF_SENSOR
  GPIO_RF_433MHZ_RX_ID,      // Rf receiver with sensor decoding
// #endif
#ifdef USE_MODULE_SENSORS_ULTRASONICS
  GPIO_SR04_TRIG_ID,      // SR04 Trigger pin
  GPIO_SR04_ECHO_ID,      // SR04 Echo pin
#endif
// #if defined(USE_ENERGY_SENSOR) && defined(USE_HLW8012)
//   GPIO_NRG_SEL_ID,        // HLW8012/HLJ-01 Sel output (1 = Voltage)
//   GPIO_NRG_SEL_INV_ID,    // HLW8012/HLJ-01 Sel output (0 = Voltage)
//   GPIO_NRG_CF1_ID,        // HLW8012/HLJ-01 CF1 voltage / current
//   GPIO_HLW_CF_ID,         // HLW8012 CF power
//   GPIO_HJL_CF_ID,         // HJL-01/BL0937 CF power
// #endif
// #if defined(USE_ENERGY_SENSOR) && defined(USE_I2C) && defined(USE_ADE7953)
  GPIO_ADE7953_IRQ_ID,    // ADE7953 IRQ
// #endif
#if defined(USE_ENERGY_SENSOR) && defined(USE_MCP39F501)
  GPIO_MCP39F5_TX_ID,     // MCP39F501 Serial interface (Shelly2)
  GPIO_MCP39F5_RX_ID,     // MCP39F501 Serial interface (Shelly2)
  GPIO_MCP39F5_RST_ID,    // MCP39F501 Reset (Shelly2)
#endif
// #if defined(USE_MODULE_ENERGY_PZEM004T_V3) || defined(USE_PZEM_DC)
  GPIO_PZEM0XX_TX_ID,     // PZEM0XX Serial interface
// #endif
// #ifdef USE_PZEM004T
  GPIO_PZEM004_RX_ID,     // PZEM004T Serial interface
// #endif
// #ifdef USE_MODULE_ENERGY_PZEM004T_V3
  GPIO_PZEM0XX_RX_MODBUS_ID,     // PZEM-014_ID,016 Serial Modbus interface
// #endif
// #ifdef USE_PZEM_DC
  GPIO_PZEM017_RX_ID,     // PZEM-003_ID,017 Serial Modbus interface
// #endif
#ifdef USE_SDM120
  GPIO_SDM120_TX_ID,      // SDM120 Serial interface
  GPIO_SDM120_RX_ID,      // SDM120 Serial interface
#endif
#ifdef USE_SDM630
  GPIO_SDM630_TX_ID,      // SDM630 Serial interface
  GPIO_SDM630_RX_ID,      // SDM630 Serial interface
#endif
#ifdef USE_SERIAL_BRIDGE
  GPIO_SBR_TX_ID,         // Serial Bridge Serial interface
  GPIO_SBR_RX_ID,         // Serial Bridge Serial interface
#endif
#ifdef USE_SENSEAIR
  GPIO_SAIR_TX_ID,        // SenseAir Serial interface
  GPIO_SAIR_RX_ID,        // SenseAir Serial interface
#endif
#ifdef USE_NOVA_SDS
  GPIO_SDS0X1_TX_ID,      // Nova Fitness SDS011 Serial interface
  GPIO_SDS0X1_RX_ID,      // Nova Fitness SDS011 Serial interface
#endif
#ifdef USE_PMS5003
  GPIO_PMS5003_ID,        // Plantower PMS5003 Serial interface
#endif
#ifdef USE_TX20_WIND_SENSOR
  GPIO_TX20_TXD_BLACK_ID, // TX20 Transmission Pin
#endif
#ifdef USE_MP3_PLAYER
  GPIO_MP3_DFR562_ID,     // RB-DFR-562_ID, DFPlayer Mini MP3 Player Serial interface
#endif
#ifdef USE_TUYA_DIMMER
  GPIO_TUYA_TX_ID,        // Tuya Serial interface
  GPIO_TUYA_RX_ID,        // Tuya Serial interface
#endif
#ifdef USE_AZ7798
  GPIO_AZ_TXD_ID,         // AZ-Instrument 7798 CO2 datalogger Serial interface
  GPIO_AZ_RXD_ID,         // AZ-Instrument 7798 CO2 datalogger Serial interface
#endif
#ifdef USE_PN532_HSU
  GPIO_PN532_TXD_ID,      // PN532 HSU Tx
  GPIO_PN532_RXD_ID,      // PN532 HSU Rx
#endif
#ifdef USE_MGC3130
  GPIO_MGC3130_XFER_ID,
  GPIO_MGC3130_RESET_ID,
#endif
#ifdef USE_MAX31855
  GPIO_MAX31855CS_ID,     // MAX31855 Serial interface
  GPIO_MAX31855CLK_ID,    // MAX31855 Serial interface
  GPIO_MAX31855DO_ID,     // MAX31855 Serial interface
#endif
#ifdef USE_SM16716
  GPIO_SM16716_CLK_ID,    // SM16716 CLOCK
  GPIO_SM16716_DAT_ID,    // SM16716 DATA
  GPIO_SM16716_SEL_ID,    // SM16716 SELECT
#endif // USE_SM16716
#ifdef ROTARY_V1
  GPIO_ROT1A_ID,          // Rotary switch1 A Pin
  GPIO_ROT1B_ID,          // Rotary switch1 B Pin
  GPIO_ROT2A_ID,          // Rotary switch2 A Pin
  GPIO_ROT2B_ID,          // Rotary switch2 B Pin
#endif
#ifdef USE_ARILUX_RF
  GPIO_ARIRFRCV_ID,       // AliLux RF Receive input
#endif
#ifdef USE_HRE
  GPIO_HRE_CLOCK_ID,
  GPIO_HRE_DATA
#endif
#ifdef USE_MODULE_SENSORS_DOOR
  GPIO_DOOR_OPEN_ID,
#endif
#ifdef USE_SENSOR_DOOR_LOCK
  GPIO_DOOR_LOCK_ID,
#endif
#ifdef USE_MODULE_DRIVERS_HBRIDGE
   GPIO_HBRIDGE_L9110_IA_ID,
   GPIO_HBRIDGE_L9110_IA_ID,
   GPIO_HBRIDGE_L9110_OA_ID,
   GPIO_HBRIDGE_L9110_OA_ID,
   GPIO_HBRIDGE_ANALOG_SENSE_ID,
#endif
};


class mHardwarePins :
  public mTaskerInterface
{
  public:
    mHardwarePins(){};
        
    static const char* PM_MODULE_CORE_HARDWAREPINS_CTR;
    static const char* PM_MODULE_CORE_HARDWAREPINS_FRIENDLY_CTR;
    PGM_P GetModuleName(){          return PM_MODULE_CORE_HARDWAREPINS_CTR; }
    PGM_P GetModuleFriendlyName(){  return PM_MODULE_CORE_HARDWAREPINS_FRIENDLY_CTR; }
    uint16_t GetModuleUniqueID(){ return D_UNIQUE_MODULE_CORE_HARDWAREPINS_ID; }
    #ifdef USE_DEBUG_CLASS_SIZE
    uint16_t GetClassSize(){      return sizeof(mHardwarePins);    };
    #endif
        
    void parse_JSONCommand(JsonParserObject obj);

    int8_t GetPinByIndex(uint8_t index);
    int8_t GetPinIndexedLocation(uint8_t pin_number);
    bool SetPinFunction(int8_t gpio_pin_number, int8_t pin_function);

    bool flag_serial_set_tx_set = false;

    /**
     * Module that is attached to the pin, indexed by ascending order of pins available on chip
     */
    uint16_t pin_attached_gpio_functions[MAX_USER_PINS] = {0};  


    static const uint16_t kList_Selectable_Function_IDs[] PROGMEM;
    static const char kModuleNames[] PROGMEM;

    /*-------------------------------------------------------------------------------------------*\
    * ESP8266 single Analog / Digital converter input
    \*-------------------------------------------------------------------------------------------*/

    #ifdef ESP8266
    // const uint16_t kAdcNiceList[] PROGMEM = {
    //   GPIO_NONE,                              // Not used
    //   GPIO_ADC_INPUT),                  // Analog inputs
    //   GPIO_ADC_TEMP),                   // Thermistor
    //   GPIO_ADC_LIGHT),                  // Light sensor
    //   GPIO_ADC_BUTTON) + MAX_KEYS,      // Button
    //   GPIO_ADC_BUTTON_INV) + MAX_KEYS,
    //   GPIO_ADC_RANGE),                  // Range
    //   GPIO_ADC_CT_POWER),               // Current
    //   GPIO_ADC_JOY),                    // Joystick
    //   GPIO_ADC_PH),                     // Analog PH Sensor
    // };
    #endif  // ESP8266

    // User selectable ADC functionality
    enum UserSelectableAdc {
      ADC_NONE,           // Not used
      ADC_INPUT,          // Analog input
      ADC_TEMP,           // Thermistor
      ADC_LIGHT,          // Light sensor
      ADC_BUTTON,         // Button
      ADC_BUTTON_INV,
      ADC_RANGE,          // Range
      ADC_CT_POWER,       // Current
      ADC_JOY,            // Joystick
      ADC_PH,             // Analog PH Sensor
    //  ADC_SWITCH,         // Switch
    //  ADC_SWITCH_INV,
      ADC_END };


    #define GPIO_FLAG_USED         2  // Currently two flags used

    #define GPIO_FLAG_ADC0_ID      1  // Allow ADC0 when define USE_ADC_VCC is disabled
    #define GPIO_FLAG_ADC0_TEMP    2  // Allow ADC0 as Temperature sensor when define USE_ADC_VCC is disabled
    #define GPIO_FLAG_SPARE02      4
    #define GPIO_FLAG_SPARE03      8
    #define GPIO_FLAG_SPARE04     16
    #define GPIO_FLAG_SPARE05     32
    #define GPIO_FLAG_SPARE06     64
    #define GPIO_FLAG_SPARE07    128


    /**
     * @brief This contains indexing for esp8266 THEN esp8285, the index (value) is important for retrieving template from either esp8266 or esp8285 arrays
     * 
     */
    static const uint16_t kModuleNiceList_IDS[] PROGMEM;
    static const char kModules_Name_list_ctr[] PROGMEM;
    static const uint16_t kModuleNiceList[] PROGMEM;
    static const mytmplt kModules[] PROGMEM;


    //  Known templates
    // {"NAME":"AITHINKER CAM","GPIO":[4992,1,1,1,1,5088,1,1,1,1,1,1,1,1,5089,5090,0,5091,5184,5152,0,5120,5024,5056,0,0,0,0,4928,1,5094,5095,5092,0,0,5093],"FLAG":0,"BASE":1}
    // {"NAME":"Olimex ESP32-PoE","GPIO":[1,1,1,1,1,1,0,0,5536,1,1,1,1,0,5600,0,0,0,0,5568,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,1],"FLAG":0,"BASE":1}
    // {"NAME":"wESP32","GPIO":[1,1,1,1,1,1,0,0,0,1,1,1,5568,5600,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,1],"FLAG":0,"BASE":1}
    // {"NAME":"Denky (Teleinfo)","GPIO":[1,1,1,1,5664,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1376,1,1,0,0,0,0,1,5632,1,1,1,0,0,1],"FLAG":0,"BASE":1}



    int8_t ConvertRealPinToIndexPin(uint8_t real_pin);

    void ModuleSettings_FlashSerial();
        
    void ParseModuleTemplate();

    void ModuleSettings_ShowTemplateLog();

    void Template_Load();

    int8_t GetRealPinNumberFromName(const char* c);
    int16_t GetGPIOFunctionIDbyName(const char* c);

    void ModuleSettings_ShowActiveTemplate();
    
    const char* GetModuleNameByID(uint8_t id, char* buffer);

    int16_t GetModuleIDbyName(const char* c);
    
    bool UsuableGPIOPin(uint8_t pin);
    // int8_t UsablePinToTemplateArrayIndex(uint8_t pin);

    const char* GetGPIOFunctionNamebyID_P(uint16_t id, char* buffer);
    PGM_P GetGPIOFunctionNamebyID_P(uint16_t id);

    bool ValidUserGPIOFunction(uint8_t* pin_array, uint8_t index);
    bool ValidUserGPIOFunction(uint16_t* pin_array, uint8_t index);


    int16_t IRAM_ATTR Pin(uint32_t gpio, uint32_t index = 0);
    boolean PinUsed(uint32_t gpio, uint32_t index = 0);
    void SetPin(uint32_t lpin, uint32_t gpio);


    int16_t GetPinWithGPIO(uint16_t gpio, uint8_t index = 0);
    uint32_t GetPin(uint32_t gpio, uint32_t index = 0);

    void DigitalWrite(uint32_t gpio_pin, uint32_t state);
    void DigitalWrite(uint32_t gpio_pin, uint32_t index, uint32_t state);
    bool DigitalRead(uint32_t gpio_pin, uint32_t index = 0);
    
    uint8_t ModuleNr();
    bool ValidTemplateModule(uint8_t index);
    bool ValidModule(uint8_t index);
    const char* AnyModuleName2(uint8_t index);

    // int jsoneq(const char *json, jsmntok_t *tok, const char *s) ;
    const char* AnyModuleName(uint8_t index, char* buffer, uint8_t buflen);

    const char* ModuleName(char* buffer, uint8_t buflen);
    void GpioInit(void);


    void TemplateGPIOs(myio *gp);
    // void TemplateGPIOs(myio *gp, uint8_t module_id);


    gpio_flag ModuleFlag();
    void ModuleDefault(uint8_t module);
    void SetModuleType();
    uint16_t ValidPin_AdjustGPIO(uint8_t pin, uint16_t gpio);
    bool ValidGPIO(uint8_t pin, uint16_t gpio);
    bool GetUsedInModule(uint8_t val, uint8_t *arr);
    bool JsonTemplate(const char* dataBuf);
    void TemplateJson();

    int8_t Tasker(uint8_t function, JsonParserObject obj = 0);
    void Pre_Init(void);




    bool ReadModuleTemplateFromProgmem();
    void ModuleTemplateJsonParser(char* buffer);

    int8_t ConvertIndexPinToRealPin(uint8_t real_pin);





};

#endif 
