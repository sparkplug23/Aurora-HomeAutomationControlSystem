#ifndef _mHardwarePins_H_
#define _mHardwarePins_H_

#define   D_UNIQUE_MODULE_CORE_HARDWAREPINS_ID ((2*1000)+5)

#include "1_TaskerManager/mTaskerManager.h"

#ifdef ESP8266
  #include "mHardwarePins_Esp82xx.h"
#endif
#ifdef ESP32
  #include "mHardwarePins_Esp32.h"
#endif
  
#include "jsmn.h"


#ifdef DEBUG_PIN1_GPIO
  #define DEBUG_PIN1_INIT()     pinMode(DEBUG_PIN1_GPIO, OUTPUT); digitalWrite(DEBUG_PIN1_GPIO, HIGH);
  #define DEBUG_PIN1_SET(X)     digitalWrite(DEBUG_PIN1_GPIO, X);
  #define DEBUG_PIN1_TOGGLE()   digitalWrite(DEBUG_PIN1_GPIO, !digitalRead(DEBUG_PIN1_GPIO));
#else
  #define DEBUG_PIN1_INIT()
  #define DEBUG_PIN1_SET(X)
  #define DEBUG_PIN1_TOGGLE()
#endif
#ifdef DEBUG_PIN2_GPIO
  #define DEBUG_PIN2_INIT()     pinMode(DEBUG_PIN2_GPIO, OUTPUT); digitalWrite(DEBUG_PIN2_GPIO, HIGH);
  #define DEBUG_PIN2_SET(X)     digitalWrite(DEBUG_PIN2_GPIO, X);
  #define DEBUG_PIN2_TOGGLE()   digitalWrite(DEBUG_PIN2_GPIO, !digitalRead(DEBUG_PIN2_GPIO));
#else
  #define DEBUG_PIN2_INIT()

  #define DEBUG_PIN2_SET(X)
  #define DEBUG_PIN2_TOGGLE()
#endif
#ifdef DEBUG_PIN3_GPIO
  #define DEBUG_PIN3_INIT()     pinMode(DEBUG_PIN3_GPIO, OUTPUT); digitalWrite(DEBUG_PIN3_GPIO, HIGH);
  #define DEBUG_PIN3_SET(X)     digitalWrite(DEBUG_PIN3_GPIO, X);
  #define DEBUG_PIN3_TOGGLE()   digitalWrite(DEBUG_PIN3_GPIO, !digitalRead(DEBUG_PIN3_GPIO));
#else 
  #define DEBUG_PIN3_INIT()
  #define DEBUG_PIN3_SET(X)
  #define DEBUG_PIN3_TOGGLE()
#endif
#ifdef DEBUG_PIN4_GPIO
  #define DEBUG_PIN4_INIT()     pinMode(DEBUG_PIN4_GPIO, OUTPUT); digitalWrite(DEBUG_PIN4_GPIO, HIGH);
  #define DEBUG_PIN4_SET(X)     digitalWrite(DEBUG_PIN4_GPIO, X);
  #define DEBUG_PIN4_TOGGLE()   digitalWrite(DEBUG_PIN4_GPIO, !digitalRead(DEBUG_PIN4_GPIO));
#else
  #define DEBUG_PIN4_INIT()
  #define DEBUG_PIN4_SET(X)
  #define DEBUG_PIN4_TOGGLE()
#endif
#ifdef DEBUG_PIN5_GPIO
  #define DEBUG_PIN5_INIT()     pinMode(DEBUG_PIN5_GPIO, OUTPUT); digitalWrite(DEBUG_PIN5_GPIO, HIGH);
  #define DEBUG_PIN5_SET(X)     digitalWrite(DEBUG_PIN5_GPIO, X);
  #define DEBUG_PIN5_TOGGLE()   digitalWrite(DEBUG_PIN5_GPIO, !digitalRead(DEBUG_PIN5_GPIO));
#else
  #define DEBUG_PIN5_INIT()
  #define DEBUG_PIN5_SET(X)
  #define DEBUG_PIN5_TOGGLE()
#endif
#ifdef DEBUG_PIN6_GPIO
  #define DEBUG_PIN6_INIT()     pinMode(DEBUG_PIN6_GPIO, OUTPUT); digitalWrite(DEBUG_PIN6_GPIO, HIGH);
  #define DEBUG_PIN6_SET(X)     digitalWrite(DEBUG_PIN6_GPIO, X);
  #define DEBUG_PIN6_TOGGLE()   digitalWrite(DEBUG_PIN6_GPIO, !digitalRead(DEBUG_PIN6_GPIO));
#else
  #define DEBUG_PIN6_INIT()
  #define DEBUG_PIN6_SET(X)
  #define DEBUG_PIN6_TOGGLE()
#endif
#ifdef DEBUG_PIN7_GPIO
  #define DEBUG_PIN7_INIT()     pinMode(DEBUG_PIN7_GPIO, OUTPUT); digitalWrite(DEBUG_PIN7_GPIO, HIGH);
  #define DEBUG_PIN7_SET(X)     digitalWrite(DEBUG_PIN7_GPIO, X);
  #define DEBUG_PIN7_TOGGLE()   digitalWrite(DEBUG_PIN7_GPIO, !digitalRead(DEBUG_PIN7_GPIO));
#else
  #define DEBUG_PIN7_INIT()
  #define DEBUG_PIN7_SET(X)
  #define DEBUG_PIN7_TOGGLE()
#endif
#ifdef DEBUG_PIN8_GPIO
  #define DEBUG_PIN8_INIT()     pinMode(DEBUG_PIN8_GPIO, OUTPUT); digitalWrite(DEBUG_PIN8_GPIO, HIGH);
  #define DEBUG_PIN8_SET(X)     digitalWrite(DEBUG_PIN8_GPIO, X);
  #define DEBUG_PIN8_TOGGLE()   digitalWrite(DEBUG_PIN8_GPIO, !digitalRead(DEBUG_PIN8_GPIO));
#else
  #define DEBUG_PIN8_INIT()
  #define DEBUG_PIN8_SET(X)
  #define DEBUG_PIN8_TOGGLE()
#endif

  
// Friendly names of gpio functions (add ifdefs later)

DEFINE_PGM_CTR(PM_GPIO_FUNCTION_NONE_CTR)              D_GPIO_FUNCTION_NONE_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_UNUSED_FORCED_LOW_CTR)         D_GPIO_FUNCTION_UNUSED_FORCED_LOW_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_UNUSED_FORCED_HIGH_CTR)        D_GPIO_FUNCTION_UNUSED_FORCED_HIGH_CTR;

// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_ANALOG_CTR)      D_GPIO_FUNCTION_ANALOG_CTR;

// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_DHT11_1_CTR)           D_GPIO_FUNCTION_DHT11_1_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_DHT11_2_CTR)           D_GPIO_FUNCTION_DHT11_2_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_DHT22_1_CTR)           D_GPIO_FUNCTION_DHT22_1_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_DHT22_2_CTR)           D_GPIO_FUNCTION_DHT22_2_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_AM2301_1_CTR)          D_GPIO_FUNCTION_AM2301_CTR "_1";
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_AM2301_2_CTR)          D_GPIO_FUNCTION_AM2301_CTR "_2";

#ifdef USE_MODULE_CORE_I2C
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_I2C_SCL_CTR)           D_GPIO_FUNCTION_I2C_SCL_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_I2C_SDA_CTR)           D_GPIO_FUNCTION_I2C_SDA_CTR;
#endif

// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_LDR_BASIC_DIGITAL1_CTR)     D_GPIO_FUNCTION_LDR_BASIC_DIGITAL1_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_LDR_BASIC_ANALOG1_CTR)      D_GPIO_FUNCTION_LDR_BASIC_ANALOG1_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_LDR_BASIC_DIGITAL2_CTR)     D_GPIO_FUNCTION_LDR_BASIC_DIGITAL2_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_LDR_BASIC_ANALOG2_CTR)      D_GPIO_FUNCTION_LDR_BASIC_ANALOG2_CTR;

#if defined(USE_MODULE_DISPLAYS_OLED_SH1106) || defined(USE_MODULE_DISPLAYS_OLED_SSD1306)
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_OLED_RESET_CTR)           D_GPIO_FUNCTION_OLED_RESET_CTR;
#endif

// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_RGB_DATA_CTR)          D_GPIO_FUNCTION_RGB_DATA_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_RGB_DATA1_CTR)          D_GPIO_FUNCTION_RGB_DATA1_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_RGB_CLOCK_CTR)         D_GPIO_FUNCTION_RGB_CLOCK_CTR;

#ifdef USE_MODULE_SENSORS_PIR
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_PIR_1_CTR)             D_GPIO_FUNCTION_PIR_1_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_PIR_2_CTR)             D_GPIO_FUNCTION_PIR_2_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_PIR_3_CTR)             D_GPIO_FUNCTION_PIR_3_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_PIR_1_INV_CTR)         D_GPIO_FUNCTION_PIR_1_INV_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_PIR_2_INV_CTR)         D_GPIO_FUNCTION_PIR_2_INV_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_PIR_3_INV_CTR)         D_GPIO_FUNCTION_PIR_3_INV_CTR;
#endif

// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_BUZZER_CTR) D_GPIO_FUNCTION_BUZZER_CTR;

#ifdef USE_MODULE_CONTROLLER_DOORCHIME
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_CHIME_INPUT_CTR)       D_GPIO_FUNCTION_CHIME_INPUT_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_CHIME_RINGER_CTR)      D_GPIO_FUNCTION_CHIME_RINGER_CTR;
#endif

// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_IRSEND_CTR)            D_GPIO_FUNCTION_IRSEND_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_FAN_IRSEND_CTR)        D_GPIO_FUNCTION_FAN_IRSEND_CTR;

#ifdef USE_MODULE_DRIVERS_RELAY
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_REL1_CTR)          D_GPIO_FUNCTION_REL1_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_REL2_CTR)          D_GPIO_FUNCTION_REL2_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_REL3_CTR)          D_GPIO_FUNCTION_REL3_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_REL4_CTR)          D_GPIO_FUNCTION_REL4_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_REL1_INV_CTR)          D_GPIO_FUNCTION_REL1_INV_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_REL2_INV_CTR)          D_GPIO_FUNCTION_REL2_INV_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_REL3_INV_CTR)          D_GPIO_FUNCTION_REL3_INV_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_REL4_INV_CTR)          D_GPIO_FUNCTION_REL4_INV_CTR;
#endif 

// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_FAN_PWM1_CTR)          D_GPIO_FUNCTION_FAN_PWM1_CTR;

// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_PWM1_CTR)          D_GPIO_FUNCTION_PWM1_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_PWM2_CTR)          D_GPIO_FUNCTION_PWM2_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_PWM3_CTR)          D_GPIO_FUNCTION_PWM3_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_PWM4_CTR)          D_GPIO_FUNCTION_PWM4_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_PWM5_CTR)          D_GPIO_FUNCTION_PWM5_CTR;

// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_PWM1_INV_CTR)          D_GPIO_FUNCTION_PWM1_INV_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_PWM2_INV_CTR)          D_GPIO_FUNCTION_PWM2_INV_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_PWM3_INV_CTR)          D_GPIO_FUNCTION_PWM3_INV_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_PWM4_INV_CTR)          D_GPIO_FUNCTION_PWM4_INV_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_PWM5_INV_CTR)          D_GPIO_FUNCTION_PWM5_INV_CTR;

#ifdef ESP32
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_HWSERIAL1_RING_BUFFER_TX_CTR) D_GPIO_FUNCTION_HWSERIAL1_RING_BUFFER_TX_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_HWSERIAL1_RING_BUFFER_RX_CTR) D_GPIO_FUNCTION_HWSERIAL1_RING_BUFFER_RX_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_HWSERIAL2_RING_BUFFER_TX_CTR) D_GPIO_FUNCTION_HWSERIAL2_RING_BUFFER_TX_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_HWSERIAL2_RING_BUFFER_RX_CTR) D_GPIO_FUNCTION_HWSERIAL2_RING_BUFFER_RX_CTR;
#endif

#ifdef ESP32
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_HWSERIAL0_TX_CTR)   D_GPIO_FUNCTION_HWSERIAL0_TX_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_HWSERIAL0_RX_CTR)   D_GPIO_FUNCTION_HWSERIAL0_RX_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_HWSERIAL1_TX_CTR)   D_GPIO_FUNCTION_HWSERIAL1_TX_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_HWSERIAL1_RX_CTR)   D_GPIO_FUNCTION_HWSERIAL1_RX_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_HWSERIAL2_TX_CTR)   D_GPIO_FUNCTION_HWSERIAL2_TX_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_HWSERIAL2_RX_CTR)   D_GPIO_FUNCTION_HWSERIAL2_RX_CTR;
#endif

// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_DEBUG_PIN1_CTR) D_GPIO_FUNCTION_DEBUG_PIN1_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_DEBUG_PIN2_CTR) D_GPIO_FUNCTION_DEBUG_PIN2_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_DEBUG_PIN3_CTR) D_GPIO_FUNCTION_DEBUG_PIN3_CTR;

// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_GPS_SERIAL0_TX_CTR)   D_GPIO_FUNCTION_GPS_SERIAL0_TX_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_GPS_SERIAL0_RX_CTR)   D_GPIO_FUNCTION_GPS_SERIAL0_RX_CTR;

#ifdef ESP32
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_GPS_SERIAL1_TX_CTR)   D_GPIO_FUNCTION_GPS_SERIAL1_TX_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_GPS_SERIAL1_RX_CTR)   D_GPIO_FUNCTION_GPS_SERIAL1_RX_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_GPS_SERIAL2_TX_CTR)   D_GPIO_FUNCTION_GPS_SERIAL2_TX_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_GPS_SERIAL2_RX_CTR)   D_GPIO_FUNCTION_GPS_SERIAL2_RX_CTR;
#endif // ESP32

#ifdef USE_MODULE_DRIVERS_LEDS
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_LEDLNK_CTR)         D_GPIO_FUNCTION_LEDLNK_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_LEDLNK_INV_CTR)         D_GPIO_FUNCTION_LED1_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_LED1_CTR)          D_GPIO_FUNCTION_LED1_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_LED2_CTR)          D_GPIO_FUNCTION_LED2_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_LED3_CTR)          D_GPIO_FUNCTION_LED3_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_LED4_CTR)          D_GPIO_FUNCTION_LED4_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_LED5_CTR)          D_GPIO_FUNCTION_LED5_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_LED1_INV_CTR)     D_GPIO_FUNCTION_LED1_INV_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_LED2_INV_CTR)     D_GPIO_FUNCTION_LED2_INV_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_LED3_INV_CTR)     D_GPIO_FUNCTION_LED3_INV_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_LED4_INV_CTR)     D_GPIO_FUNCTION_LED4_INV_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_LED5_INV_CTR)     D_GPIO_FUNCTION_LED5_INV_CTR;
#endif

#ifdef USE_MODULE_ENERGY_PZEM004T_V3
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_PZEM0XX_TX_CTR)     D_GPIO_FUNCTION_PZEM0XX_TX_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_PZEM0XX_MODBUS__RX_CTR)     D_GPIO_FUNCTION_PZEM0XX_RX_MODBUS_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_PZEM004_RX_CTR)     D_GPIO_FUNCTION_PZEM004_RX_CTR;
#endif

// // #ifdef USE_MODULE_SENSORS_ULTRASONICS
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SR04_ECHO_CTR)     D_GPIO_FUNCTION_SR04_ECHO_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SR04_TRIG_CTR)     D_GPIO_FUNCTION_SR04_TRIG_CTR;
// // #endif

// // #ifdef USE_MODULE_SENSORS_ULTRASONICS
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION__ROTARY_ENCODER_A__CTR)     D_GPIO_FUNCTION__ROTARY_ENCODER_A__CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION__ROTARY_ENCODER_B__CTR)     D_GPIO_FUNCTION__ROTARY_ENCODER_B__CTR;
// // #endif


/******************************************************************************************************************
 * Network
*******************************************************************************************************************/

/******************************************************************************************************************
 * Drivers
*******************************************************************************************************************/

/******************************************************************************************************************
 * Sensors
*******************************************************************************************************************/

#ifdef USE_MODULE_SENSORS_SWITCHES
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SWT1_CTR)         D_GPIO_FUNCTION_SWT1_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SWT2_CTR)         D_GPIO_FUNCTION_SWT2_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SWT3_CTR)         D_GPIO_FUNCTION_SWT3_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SWT4_CTR)         D_GPIO_FUNCTION_SWT3_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SWT5_CTR)         D_GPIO_FUNCTION_SWT4_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SWT6_CTR)         D_GPIO_FUNCTION_SWT5_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SWT7_CTR)         D_GPIO_FUNCTION_SWT6_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SWT8_CTR)         D_GPIO_FUNCTION_SWT7_CTR;

// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SWT1_INV_CTR)         D_GPIO_FUNCTION_SWT1_INV_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SWT2_INV_CTR)         D_GPIO_FUNCTION_SWT2_INV_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SWT3_INV_CTR)         D_GPIO_FUNCTION_SWT3_INV_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SWT4_INV_CTR)         D_GPIO_FUNCTION_SWT4_INV_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SWT5_INV_CTR)         D_GPIO_FUNCTION_SWT5_INV_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SWT6_INV_CTR)         D_GPIO_FUNCTION_SWT6_INV_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SWT7_INV_CTR)         D_GPIO_FUNCTION_SWT7_INV_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SWT8_INV_CTR)         D_GPIO_FUNCTION_SWT8_INV_CTR;

// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SWT1_NP_CTR)         D_GPIO_FUNCTION_SWT1_NP_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SWT2_NP_CTR)         D_GPIO_FUNCTION_SWT2_NP_CTR;



DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SWT_NUM_CTR)           "SWT%d";
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SWT_NUM_INV_CTR)         "SWT%d Inv";
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SWT_NUM_NP_CTR)         "SWT%d_NP";
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SWT_NUM_INV_NP_CTR)         "SWT%d Inv NP";

#endif // USE_MODULE_SENSORS_SWITCHES

#ifdef USE_MODULE_SENSORS_BUTTONS
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_KEY1_CTR)      D_GPIO_FUNCTION_KEY1_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_KEY2_CTR)      D_GPIO_FUNCTION_KEY2_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_KEY3_CTR)      D_GPIO_FUNCTION_KEY3_CTR;

// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_KEY1_INV_CTR)      D_GPIO_FUNCTION_KEY1_INV_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_KEY2_INV_CTR)      D_GPIO_FUNCTION_KEY2_INV_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_KEY3_INV_CTR)      D_GPIO_FUNCTION_KEY3_INV_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_KEY4_INV_CTR)      D_GPIO_FUNCTION_KEY4_INV_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_KEY5_INV_CTR)      D_GPIO_FUNCTION_KEY5_INV_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_KEY6_INV_CTR)      D_GPIO_FUNCTION_KEY6_INV_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_KEY7_INV_CTR)      D_GPIO_FUNCTION_KEY7_INV_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_KEY8_INV_CTR)      D_GPIO_FUNCTION_KEY8_INV_CTR;

// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_KEY1_TOUCH_CTR)      D_GPIO_FUNCTION_KEY1_TOUCH_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_KEY2_TOUCH_CTR)      D_GPIO_FUNCTION_KEY2_TOUCH_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_KEY3_TOUCH_CTR)      D_GPIO_FUNCTION_KEY3_TOUCH_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_KEY4_TOUCH_CTR)      D_GPIO_FUNCTION_KEY4_TOUCH_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_KEY5_TOUCH_CTR)      D_GPIO_FUNCTION_KEY5_TOUCH_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_KEY6_TOUCH_CTR)      D_GPIO_FUNCTION_KEY6_TOUCH_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_KEY7_TOUCH_CTR)      D_GPIO_FUNCTION_KEY7_TOUCH_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_KEY8_TOUCH_CTR)      D_GPIO_FUNCTION_KEY8_TOUCH_CTR;


// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_KEY1_NP_CTR)      D_GPIO_FUNCTION_KEY1_NP_CTR;

// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_KEY1_PULLDOWN_CTR)      D_GPIO_FUNCTION_KEY1_PULLDOWN_CTR;


DEFINE_PGM_CTR(PM_GPIO_FUNCTION_KEY_NUM_CTR)           "Key%d";
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_KEY_NUM_INV_CTR)         "Key%d Inv";
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_KEY_NUM_NP_CTR)         "Key%d NP";
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_KEY_NUM_INV_NP_CTR)         "Key%d PD";
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_KEY_NUM_TOUCH_CTR)         "Key%d Touch";



#endif // USE_MODULE_SENSORS_BUTTONS

#ifdef USE_MODULE_SENSORS__DS18X20_ESP32_2023
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_DS18X20_1_CTR)         D_GPIO_FUNCTION_DS18X20_1_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_DS18X20_2_CTR)         D_GPIO_FUNCTION_DS18X20_2_CTR;
#endif

#ifdef USE_MODULE_SENSORS_DOOR
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_DOOR_OPEN_CTR)           D_GPIO_FUNCTION_DOOR_OPEN_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_DOOR_LOCK_CTR)           D_GPIO_FUNCTION_DOOR_LOCK_CTR;
#endif

/******************************************************************************************************************
 * Lights
*******************************************************************************************************************/

/******************************************************************************************************************
 * Energy
*******************************************************************************************************************/

#ifdef USE_MODULE_ENERGY_ADE7953
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_ADE7953_IRQ_CTR)  D_GPIO_FUNCTION_ADE7953_IRQ_CTR;
#endif

/******************************************************************************************************************
 * Displays
*******************************************************************************************************************/
#ifdef USE_MODULE_DISPLAYS_NEXTION
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_NEXTION_TX_CTR)     D_GPIO_FUNCTION_NEXTION_TX_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_NEXTION_RX_CTR)     D_GPIO_FUNCTION_NEXTION_RX_CTR;
#endif // USE_MODULE_DISPLAYS_NEXTION

// DEFINE_PGM_CTR(PM_GPIO_FUNCTION__RF_433MHZ_RX__CTR)      D_GPIO_FUNCTION__RF_433MHZ_RX__CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION__RF_433MHZ_TX__CTR)      D_GPIO_FUNCTION__RF_433MHZ_TX__CTR;

// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SERIAL_DEBUG_TX_CTR)  D_GPIO_FUNCTION_SERIAL_DEBUG_TX_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SERIAL_DEBUG_RX_CTR)  D_GPIO_FUNCTION_SERIAL_DEBUG_RX_CTR;

// DEFINE_PGM_CTR(PM_GPIO_FUNCTION__FONA_POWER_KEY__CTR)       D_GPIO_FUNCTION__FONA_POWER_KEY__CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION__FONA_POWER_STATUS__CTR)    D_GPIO_FUNCTION__FONA_POWER_STATUS__CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION__FONA_NETWORK_STATUS__CTR)  D_GPIO_FUNCTION__FONA_NETWORK_STATUS__CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION__FONA_RESET__CTR)           D_GPIO_FUNCTION__FONA_RESET__CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION__FONA_UART_TX__CTR)         D_GPIO_FUNCTION__FONA_UART_TX__CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION__FONA_UART_RX__CTR)         D_GPIO_FUNCTION__FONA_UART_RX__CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION__FONA_RING_INDICATOR__CTR)  D_GPIO_FUNCTION__FONA_RING_INDICATOR__CTR;

// DEFINE_PGM_CTR(PM_GPIO_FUNCTION__MODEM_DATA_TERMINAL_READY_DTR__CTR)           D_GPIO_FUNCTION__MODEM_DATA_TERMINAL_READY_DTR__CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION__MODEM_TX__CTR)         D_GPIO_FUNCTION__MODEM_TX__CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION__MODEM_RX__CTR)         D_GPIO_FUNCTION__MODEM_RX__CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION__MODEM_POWER__CTR)  D_GPIO_FUNCTION__MODEM_POWER__CTR;

// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_HBRIDGE_L9110_IA_CTR) D_GPIO_FUNCTION_HBRIDGE_L9110_IA_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_HBRIDGE_L9110_IB_CTR) D_GPIO_FUNCTION_HBRIDGE_L9110_IB_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_HBRIDGE_L9110_OA_CTR) D_GPIO_FUNCTION_HBRIDGE_L9110_OA_CTR;
// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_HBRIDGE_L9110_OB_CTR) D_GPIO_FUNCTION_HBRIDGE_L9110_OB_CTR;

// DEFINE_PGM_CTR(PM_GPIO_FUNCTION_ANALOG_POSITION_CTR) D_GPIO_FUNCTION_ANALOG_POSITION_CTR;

#ifdef ESP32

DEFINE_PGM_CTR(PM_GPIO_FUNCTION_ADC1_CH4_CTR) D_GPIO_FUNCTION_ADC1_CH4_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_ADC1_CH6_CTR) D_GPIO_FUNCTION_ADC1_CH6_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_ADC1_CH7_CTR) D_GPIO_FUNCTION_ADC1_CH7_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_EXTERNAL_INTERRUPT_TRIGGER_CTR) D_GPIO_FUNCTION_EXTERNAL_INTERRUPT_TRIGGER_CTR;

DEFINE_PGM_CTR(PM_GPIO_FUNCTION_RXON_SAMPLING_ENABLED_CTR)   D_GPIO_FUNCTION_RXON_SAMPLING_ENABLED_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_CC1110_SYNC_PULSE_SIGNAL_CTR)   D_GPIO_FUNCTION_CC1110_SYNC_PULSE_SIGNAL_CTR;

DEFINE_PGM_CTR(PM_GPIO_FUNCTION_WEBCAM_XCLK_CTR)            D_GPIO_WEBCAM_XCLK_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_WEBCAM_DATA1_CTR)            D_GPIO_WEBCAM_DATA1_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_WEBCAM_DATA2_CTR)            D_GPIO_WEBCAM_DATA2_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_WEBCAM_DATA3_CTR)            D_GPIO_WEBCAM_DATA3_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_WEBCAM_DATA4_CTR)            D_GPIO_WEBCAM_DATA4_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_WEBCAM_DATA5_CTR)            D_GPIO_WEBCAM_DATA5_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_WEBCAM_DATA6_CTR)           D_GPIO_WEBCAM_DATA6_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_WEBCAM_DATA7_CTR)            D_GPIO_WEBCAM_DATA7_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_WEBCAM_DATA8_CTR)            D_GPIO_WEBCAM_DATA8_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_WEBCAM_PCLK_CTR)            D_GPIO_WEBCAM_PCLK_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_WEBCAM_HREF_CTR)            D_GPIO_WEBCAM_HREF_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_WEBCAM_VSYNC_CTR)            D_GPIO_WEBCAM_VSYNC_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_WEBCAM_SIOD_CTR)            D_GPIO_WEBCAM_SIOD_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_WEBCAM_SIOC_CTR)            D_GPIO_WEBCAM_SIOC_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_WEBCAM_PWDN_CTR)            D_GPIO_WEBCAM_PWDN_CTR;

DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SDCARD_VSPI_CSO_CTR)   D_GPIO_FUNCTION_SDCARD_VSPI_CSO_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SDCARD_VSPI_CLK_CTR)   D_GPIO_FUNCTION_SDCARD_VSPI_CLK_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SDCARD_VSPI_MOSI_CTR)  D_GPIO_FUNCTION_SDCARD_VSPI_MOSI_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SDCARD_VSPI_MISO_CTR)  D_GPIO_FUNCTION_SDCARD_VSPI_MISO_CTR;

DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SDCARD_HSPI_CSO_CTR)   D_GPIO_FUNCTION_SDCARD_HSPI_CSO_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SDCARD_HSPI_CLK_CTR)   D_GPIO_FUNCTION_SDCARD_HSPI_CLK_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SDCARD_HSPI_MOSI_CTR)  D_GPIO_FUNCTION_SDCARD_HSPI_MOSI_CTR;
DEFINE_PGM_CTR(PM_GPIO_FUNCTION_SDCARD_HSPI_MISO_CTR)  D_GPIO_FUNCTION_SDCARD_HSPI_MISO_CTR;

#endif

/**********MODULE CONFIG**********************************************************************************/
/**********MODULE CONFIG**********************************************************************************/

// Create ifdefs to include certain module templates
#define USE_MODULE_TEMPLATE_SONOFF_BASIC
#define USE_MODULE_TEMPLATE_SONOFF_BASIC_EXTERNAL
#define USE_MODULE_TEMPLATE_H801
#define USE_MODULE_TEMPLATE_MAGICHOME
#define USE_MODULE_TEMPLATE_SHELLY1
#define USE_MODULE_TEMPLATE_SHELLY_2P5
#define USE_MODULE_TEMPLATE_SHELLY_DIMMER2

#define USE_MODULE_TEMPLATE_DEFAULT_WEMOS
#define USE_MODULE_TEMPLATE_SONOFF_IFAN03
#define USE_MODULE_TEMPLATE_SONOFF_4CHPRO




DEFINE_PGM_CTR(PM_MODULE_NAME_NODEMCU_CTR)          D_MODULE_NAME_NODEMCU_CTR;
DEFINE_PGM_CTR(PM_MODULE_NAME_USERMODULE_CTR)          D_MODULE_NAME_USERMODULE_CTR;
#ifdef USE_MODULE_TEMPLATE_SONOFF_BASIC
  DEFINE_PGM_CTR(PM_MODULE_NAME_SONOFF_BASIC_CTR)     D_MODULE_NAME_SONOFF_BASIC_CTR;
#endif
#ifdef USE_MODULE_TEMPLATE_SONOFF_BASIC_EXTERNAL
  DEFINE_PGM_CTR(PM_MODULE_NAME_SONOFF_BASIC_EXTERNAL_CTR)     D_MODULE_NAME_SONOFF_BASIC_EXTERNAL_CTR;
#endif
#ifdef USE_MODULE_TEMPLATE_H801
  DEFINE_PGM_CTR(PM_MODULE_NAME_H801_CTR)             D_MODULE_NAME_H801_CTR;
#endif
#ifdef USE_MODULE_TEMPLATE_MAGICHOME
  DEFINE_PGM_CTR(PM_MODULE_NAME_MAGICHOME_CTR)        D_MODULE_NAME_MAGICHOME_CTR;
#endif
#ifdef USE_MODULE_TEMPLATE_SHELLY1
  DEFINE_PGM_CTR(PM_MODULE_NAME_SHELLY1_CTR)     D_MODULE_NAME_SHELLY1_CTR;
#endif
#ifdef USE_MODULE_TEMPLATE_SHELLY_2P5
  DEFINE_PGM_CTR(PM_MODULE_NAME_SHELLY2P5_CTR)     D_MODULE_NAME_SHELLY2P5_CTR;
#endif
#ifdef USE_MODULE_TEMPLATE_SHELLY_DIMMER2
  DEFINE_PGM_CTR(PM_MODULE_NAME_SHELLY_DIMMER2_CTR)     D_MODULE_NAME_SHELLY_DIMMER2_CTR;
#endif
#ifdef USE_MODULE_TEMPLATE_SONOFF_4CHPRO
  DEFINE_PGM_CTR(PM_MODULE_NAME_SONOFF_4CHPRO_CTR)     D_MODULE_NAME_SONOFF_4CHPRO_CTR;
#endif
#ifdef USE_MODULE_TEMPLATE_SONOFF_IFAN03
  DEFINE_PGM_CTR(PM_MODULE_NAME_SONOFF_IFAN03_CTR)     D_MODULE_NAME_SONOFF_IFAN03_CTR;
#endif

#define USE_GPIO_ENUM_SWITCHES_32
#define USE_GPIO_ENUM_BUTTONS_32


/**
 * @brief Enum list defining all GPIO functions that is fixed, unique and non changing across builds and hardware
 * @note This list will always be created in its full form
 * @note INV = Inverted pin, low/ground is active
 * @note NP  = No pullup/down 
 * @note Never add `#ifdef` into this enum, as I want all GPIO to always exist and be static for long term debug. `ifdef` should be considered around nicelist
 * @note PD = Pulled down (hardware dependant)
 */
enum GPIO_COMPLETE_STATIC_LIST_IDS {
  // Default for unused
  GPIO_NONE_ID,
  GPIO_ANALOG_ID, // basic analog that any enabled modules can use on the esp8266, this will need changed to be numbers so esp8266 defaults to 1 and esp32 cna use them all
  // DHT11/22 pins (enabled auto detect?)
  GPIO_DHT11_1OF2_ID, GPIO_DHT11_2OF2_ID,
  // DHT22
  GPIO_DHT22_1OF2_ID, GPIO_DHT22_2OF2_ID,
  // DallasTemperaure 1-wire sensor
  GPIO_DSB_1OF2_ID, GPIO_DSB_2OF2_ID,
  // I2C
  GPIO_I2C_SCL_ID, GPIO_I2C_SDA_ID,
  // With IC connects that need to be set high/low when unused for stability eg level shifters
  GPIO_UNUSED_FORCED_HIGH_ID,
  GPIO_UNUSED_FORCED_LOW_ID,  
  // IR Transceiver
  GPIO_IRSEND_ID, GPIO_IRRECV_ID,
  // Switches = 8. User connected external switches (No longer using offset, making discrete options)

  // Normal switches (1 to 8)
  GPIO_SWT1_ID, GPIO_SWT2_ID, GPIO_SWT3_ID, GPIO_SWT4_ID, GPIO_SWT5_ID, GPIO_SWT6_ID, GPIO_SWT7_ID, GPIO_SWT8_ID,
  #ifdef USE_GPIO_ENUM_SWITCHES_32
  // Normal switches (9 to 32)
  GPIO_SWT9_ID, GPIO_SWT10_ID, GPIO_SWT11_ID, GPIO_SWT12_ID, GPIO_SWT13_ID, GPIO_SWT14_ID, GPIO_SWT15_ID, GPIO_SWT16_ID,
  GPIO_SWT17_ID, GPIO_SWT18_ID, GPIO_SWT19_ID, GPIO_SWT20_ID, GPIO_SWT21_ID, GPIO_SWT22_ID, GPIO_SWT23_ID, GPIO_SWT24_ID,
  GPIO_SWT25_ID, GPIO_SWT26_ID, GPIO_SWT27_ID, GPIO_SWT28_ID, GPIO_SWT29_ID, GPIO_SWT30_ID, GPIO_SWT31_ID, GPIO_SWT32_ID,
  #endif // USE_GPIO_ENUM_SWITCHES_32
  // Inverted switches (1 to 8)
  GPIO_SWT1_INV_ID, GPIO_SWT2_INV_ID, GPIO_SWT3_INV_ID, GPIO_SWT4_INV_ID, GPIO_SWT5_INV_ID, GPIO_SWT6_INV_ID, GPIO_SWT7_INV_ID, GPIO_SWT8_INV_ID,
  #ifdef USE_GPIO_ENUM_SWITCHES_32
  // Inverted switches (9 to 32)
  GPIO_SWT9_INV_ID, GPIO_SWT10_INV_ID, GPIO_SWT11_INV_ID, GPIO_SWT12_INV_ID, GPIO_SWT13_INV_ID, GPIO_SWT14_INV_ID, GPIO_SWT15_INV_ID, GPIO_SWT16_INV_ID,
  GPIO_SWT17_INV_ID, GPIO_SWT18_INV_ID, GPIO_SWT19_INV_ID, GPIO_SWT20_INV_ID, GPIO_SWT21_INV_ID, GPIO_SWT22_INV_ID, GPIO_SWT23_INV_ID, GPIO_SWT24_INV_ID,
  GPIO_SWT25_INV_ID, GPIO_SWT26_INV_ID, GPIO_SWT27_INV_ID, GPIO_SWT28_INV_ID, GPIO_SWT29_INV_ID, GPIO_SWT30_INV_ID, GPIO_SWT31_INV_ID, GPIO_SWT32_INV_ID,
  #endif // USE_GPIO_ENUM_SWITCHES_32
  // Non-pull switches (1 to 8)
  GPIO_SWT1_NP_ID, GPIO_SWT2_NP_ID, GPIO_SWT3_NP_ID, GPIO_SWT4_NP_ID, GPIO_SWT5_NP_ID, GPIO_SWT6_NP_ID, GPIO_SWT7_NP_ID, GPIO_SWT8_NP_ID,
  #ifdef USE_GPIO_ENUM_SWITCHES_32
  // Non-pull switches (9 to 32)
  GPIO_SWT9_NP_ID, GPIO_SWT10_NP_ID, GPIO_SWT11_NP_ID, GPIO_SWT12_NP_ID, GPIO_SWT13_NP_ID, GPIO_SWT14_NP_ID, GPIO_SWT15_NP_ID, GPIO_SWT16_NP_ID,
  GPIO_SWT17_NP_ID, GPIO_SWT18_NP_ID, GPIO_SWT19_NP_ID, GPIO_SWT20_NP_ID, GPIO_SWT21_NP_ID, GPIO_SWT22_NP_ID, GPIO_SWT23_NP_ID, GPIO_SWT24_NP_ID,
  GPIO_SWT25_NP_ID, GPIO_SWT26_NP_ID, GPIO_SWT27_NP_ID, GPIO_SWT28_NP_ID, GPIO_SWT29_NP_ID, GPIO_SWT30_NP_ID, GPIO_SWT31_NP_ID, GPIO_SWT32_NP_ID,
  #endif // USE_GPIO_ENUM_SWITCHES_32
  // Inverted non-pull switches (1 to 8)
  GPIO_SWT1_INV_NP_ID, GPIO_SWT2_INV_NP_ID, GPIO_SWT3_INV_NP_ID, GPIO_SWT4_INV_NP_ID, GPIO_SWT5_INV_NP_ID, GPIO_SWT6_INV_NP_ID, GPIO_SWT7_INV_NP_ID, GPIO_SWT8_INV_NP_ID,
  #ifdef USE_GPIO_ENUM_SWITCHES_32
  // Inverted non-pull switches (9 to 32)
  GPIO_SWT9_INV_NP_ID, GPIO_SWT10_INV_NP_ID, GPIO_SWT11_INV_NP_ID, GPIO_SWT12_INV_NP_ID, GPIO_SWT13_INV_NP_ID, GPIO_SWT14_INV_NP_ID, GPIO_SWT15_INV_NP_ID, GPIO_SWT16_INV_NP_ID,
  GPIO_SWT17_INV_NP_ID, GPIO_SWT18_INV_NP_ID, GPIO_SWT19_INV_NP_ID, GPIO_SWT20_INV_NP_ID, GPIO_SWT21_INV_NP_ID, GPIO_SWT22_INV_NP_ID, GPIO_SWT23_INV_NP_ID, GPIO_SWT24_INV_NP_ID,
  GPIO_SWT25_INV_NP_ID, GPIO_SWT26_INV_NP_ID, GPIO_SWT27_INV_NP_ID, GPIO_SWT28_INV_NP_ID, GPIO_SWT29_INV_NP_ID, GPIO_SWT30_INV_NP_ID, GPIO_SWT31_INV_NP_ID, GPIO_SWT32_INV_NP_ID,
  #endif // USE_GPIO_ENUM_SWITCHES_32


  // Buttons = 4 (rename keys to buttons)
  // Normal keys (1 to 8)
  GPIO_KEY1_ID, GPIO_KEY2_ID, GPIO_KEY3_ID, GPIO_KEY4_ID, GPIO_KEY5_ID, GPIO_KEY6_ID, GPIO_KEY7_ID, GPIO_KEY8_ID,
  #ifdef USE_GPIO_ENUM_BUTTONS_32
  // Normal keys (9 to 32)
  GPIO_KEY9_ID, GPIO_KEY10_ID, GPIO_KEY11_ID, GPIO_KEY12_ID, GPIO_KEY13_ID, GPIO_KEY14_ID, GPIO_KEY15_ID, GPIO_KEY16_ID,
  GPIO_KEY17_ID, GPIO_KEY18_ID, GPIO_KEY19_ID, GPIO_KEY20_ID, GPIO_KEY21_ID, GPIO_KEY22_ID, GPIO_KEY23_ID, GPIO_KEY24_ID,
  GPIO_KEY25_ID, GPIO_KEY26_ID, GPIO_KEY27_ID, GPIO_KEY28_ID, GPIO_KEY29_ID, GPIO_KEY30_ID, GPIO_KEY31_ID, GPIO_KEY32_ID,
  #endif // USE_GPIO_ENUM_BUTTONS_32
  // Inverted keys (1 to 8)
  GPIO_KEY1_INV_ID, GPIO_KEY2_INV_ID, GPIO_KEY3_INV_ID, GPIO_KEY4_INV_ID, GPIO_KEY5_INV_ID, GPIO_KEY6_INV_ID, GPIO_KEY7_INV_ID, GPIO_KEY8_INV_ID,
  #ifdef USE_GPIO_ENUM_BUTTONS_32
  // Inverted keys (9 to 32)
  GPIO_KEY9_INV_ID, GPIO_KEY10_INV_ID, GPIO_KEY11_INV_ID, GPIO_KEY12_INV_ID, GPIO_KEY13_INV_ID, GPIO_KEY14_INV_ID, GPIO_KEY15_INV_ID, GPIO_KEY16_INV_ID,
  GPIO_KEY17_INV_ID, GPIO_KEY18_INV_ID, GPIO_KEY19_INV_ID, GPIO_KEY20_INV_ID, GPIO_KEY21_INV_ID, GPIO_KEY22_INV_ID, GPIO_KEY23_INV_ID, GPIO_KEY24_INV_ID,
  GPIO_KEY25_INV_ID, GPIO_KEY26_INV_ID, GPIO_KEY27_INV_ID, GPIO_KEY28_INV_ID, GPIO_KEY29_INV_ID, GPIO_KEY30_INV_ID, GPIO_KEY31_INV_ID, GPIO_KEY32_INV_ID,
  #endif // USE_GPIO_ENUM_BUTTONS_32
  // Non-pull keys (1 to 8)
  GPIO_KEY1_NP_ID, GPIO_KEY2_NP_ID, GPIO_KEY3_NP_ID, GPIO_KEY4_NP_ID, GPIO_KEY5_NP_ID, GPIO_KEY6_NP_ID, GPIO_KEY7_NP_ID, GPIO_KEY8_NP_ID,
  #ifdef USE_GPIO_ENUM_BUTTONS_32
  // Non-pull keys (9 to 32)
  GPIO_KEY9_NP_ID, GPIO_KEY10_NP_ID, GPIO_KEY11_NP_ID, GPIO_KEY12_NP_ID, GPIO_KEY13_NP_ID, GPIO_KEY14_NP_ID, GPIO_KEY15_NP_ID, GPIO_KEY16_NP_ID,
  GPIO_KEY17_NP_ID, GPIO_KEY18_NP_ID, GPIO_KEY19_NP_ID, GPIO_KEY20_NP_ID, GPIO_KEY21_NP_ID, GPIO_KEY22_NP_ID, GPIO_KEY23_NP_ID, GPIO_KEY24_NP_ID,
  GPIO_KEY25_NP_ID, GPIO_KEY26_NP_ID, GPIO_KEY27_NP_ID, GPIO_KEY28_NP_ID, GPIO_KEY29_NP_ID, GPIO_KEY30_NP_ID, GPIO_KEY31_NP_ID, GPIO_KEY32_NP_ID,
  #endif // USE_GPIO_ENUM_BUTTONS_32
  // Inverted non-pull keys (1 to 8)
  GPIO_KEY1_INV_NP_ID, GPIO_KEY2_INV_NP_ID, GPIO_KEY3_INV_NP_ID, GPIO_KEY4_INV_NP_ID, GPIO_KEY5_INV_NP_ID, GPIO_KEY6_INV_NP_ID, GPIO_KEY7_INV_NP_ID, GPIO_KEY8_INV_NP_ID,
  #ifdef USE_GPIO_ENUM_BUTTONS_32
  // Inverted non-pull keys (9 to 32)
  GPIO_KEY9_INV_NP_ID, GPIO_KEY10_INV_NP_ID, GPIO_KEY11_INV_NP_ID, GPIO_KEY12_INV_NP_ID, GPIO_KEY13_INV_NP_ID, GPIO_KEY14_INV_NP_ID, GPIO_KEY15_INV_NP_ID, GPIO_KEY16_INV_NP_ID,
  GPIO_KEY17_INV_NP_ID, GPIO_KEY18_INV_NP_ID, GPIO_KEY19_INV_NP_ID, GPIO_KEY20_INV_NP_ID, GPIO_KEY21_INV_NP_ID, GPIO_KEY22_INV_NP_ID, GPIO_KEY23_INV_NP_ID, GPIO_KEY24_INV_NP_ID,
  GPIO_KEY25_INV_NP_ID, GPIO_KEY26_INV_NP_ID, GPIO_KEY27_INV_NP_ID, GPIO_KEY28_INV_NP_ID, GPIO_KEY29_INV_NP_ID, GPIO_KEY30_INV_NP_ID, GPIO_KEY31_INV_NP_ID, GPIO_KEY32_INV_NP_ID,
  #endif // USE_GPIO_ENUM_BUTTONS_32
  // Touch keys (1 to 8)
  GPIO_KEY1_TOUCH_ID, GPIO_KEY2_TOUCH_ID, GPIO_KEY3_TOUCH_ID, GPIO_KEY4_TOUCH_ID, GPIO_KEY5_TOUCH_ID, GPIO_KEY6_TOUCH_ID, GPIO_KEY7_TOUCH_ID, GPIO_KEY8_TOUCH_ID,
  #ifdef USE_GPIO_ENUM_BUTTONS_32
  // Touch keys (9 to 32)
  GPIO_KEY9_TOUCH_ID, GPIO_KEY10_TOUCH_ID, GPIO_KEY11_TOUCH_ID, GPIO_KEY12_TOUCH_ID, GPIO_KEY13_TOUCH_ID, GPIO_KEY14_TOUCH_ID, GPIO_KEY15_TOUCH_ID, GPIO_KEY16_TOUCH_ID,
  GPIO_KEY17_TOUCH_ID, GPIO_KEY18_TOUCH_ID, GPIO_KEY19_TOUCH_ID, GPIO_KEY20_TOUCH_ID, GPIO_KEY21_TOUCH_ID, GPIO_KEY22_TOUCH_ID, GPIO_KEY23_TOUCH_ID, GPIO_KEY24_TOUCH_ID,
  GPIO_KEY25_TOUCH_ID, GPIO_KEY26_TOUCH_ID, GPIO_KEY27_TOUCH_ID, GPIO_KEY28_TOUCH_ID, GPIO_KEY29_TOUCH_ID, GPIO_KEY30_TOUCH_ID, GPIO_KEY31_TOUCH_ID, GPIO_KEY32_TOUCH_ID,
  #endif // USE_GPIO_ENUM_BUTTONS_32


  //unknown button options?
  GPIO_CNTR1_ID, GPIO_CNTR2_ID, GPIO_CNTR3_ID, GPIO_CNTR4_ID,
  GPIO_CNTR1_NP_ID, GPIO_CNTR2_NP_ID, GPIO_CNTR3_NP_ID, GPIO_CNTR4_NP_ID,
  // Relays
  GPIO_REL1_ID, GPIO_REL2_ID, GPIO_REL3_ID, GPIO_REL4_ID, GPIO_REL5_ID, GPIO_REL6_ID, GPIO_REL7_ID, GPIO_REL8_ID,
  GPIO_REL1_INV_ID, GPIO_REL2_INV_ID, GPIO_REL3_INV_ID, GPIO_REL4_INV_ID, GPIO_REL5_INV_ID, GPIO_REL6_INV_ID, GPIO_REL7_INV_ID, GPIO_REL8_INV_ID,
  // PWM 2023: PWM Channels are no longer part of lighting
  GPIO_PWM1_ID, GPIO_PWM2_ID, GPIO_PWM3_ID, GPIO_PWM4_ID, GPIO_PWM5_ID,
  GPIO_PWM1_INV_ID, GPIO_PWM2_INV_ID, GPIO_PWM3_INV_ID, GPIO_PWM4_INV_ID, GPIO_PWM5_INV_ID,
  // LEDs
  GPIO_LED1_ID, GPIO_LED2_ID, GPIO_LED3_ID, GPIO_LED4_ID,
  GPIO_LED1_INV_ID, GPIO_LED2_INV_ID, GPIO_LED3_INV_ID, GPIO_LED4_INV_ID,
  // MH-Z19 Serial interface
  GPIO_MHZ_TXD_ID, GPIO_MHZ_RXD_ID,
  // SenseAir Serial interface
  GPIO_SAIR_TX_ID, GPIO_SAIR_RX_ID,
  // SPI Chip Select, SPI Data Direction
  GPIO_SPI_CS_ID, GPIO_SPI_DC_ID,
  // Serial Bridge Serial interface
  GPIO_SBR_TX_ID, GPIO_SBR_RX_ID,
  // SR04 ultrasonic
  GPIO_SR04_TRIG_ID, GPIO_SR04_ECHO_ID,
  // Rotary Encoder (e.g. LPD3806-360BM-G5-24C)
  GPIO__ROTARY_ENCODER_A__ID, GPIO__ROTARY_ENCODER_B__ID,
  // LDR Basic
  GPIO_LDR_BASIC_DIGITAL1_ID, GPIO_LDR_BASIC_ANALOG1_ID,
  GPIO_LDR_BASIC_DIGITAL2_ID, GPIO_LDR_BASIC_ANALOG2_ID,
  // SDMxx interfaces
  GPIO_SDM120_TX_ID, GPIO_SDM120_RX_ID, GPIO_SDM630_TX_ID, GPIO_SDM630_RX_ID,
  // PZEM0XX Serial interface, PZEM004T Serial interface, PZEM-014_ID,016 Serial Modbus interface, PZEM-003_ID,017 Serial Modbus interface 
  GPIO_PZEM0XX_TX_ID, GPIO_PZEM004_RX_ID, GPIO_PZEM0XX_RX_MODBUS_ID, GPIO_PZEM017_RX_ID,
  // HX711 Load Cell
  GPIO_HX711_SCK_ID, GPIO_HX711_DAT_ID,
  // RF Transceiver
  GPIO_RFSEND_ID, GPIO_RFRECV_ID,
  // Tuya Serial interface
  GPIO_TUYA_TX_ID, GPIO_TUYA_RX_ID,
  // Software SPI (Master Input Slave Output, Master Output Slave Input, Serial Clock, Chip Select, Data or Command)
  GPIO_SSPI_MISO_ID, GPIO_SSPI_MOSI_ID, GPIO_SSPI_SCLK_ID, GPIO_SSPI_CS_ID, GPIO_SSPI_DC_ID,
  // Energy monitor chip = MCP39F501 Serial interface (Shelly2)
  GPIO_MCP39F5_TX_ID, GPIO_MCP39F5_RX_ID, GPIO_MCP39F5_RST_ID,
  // CSE7766 Serial interface (S31 and Pow R2)
  GPIO_CSE7766_TX_ID, GPIO_CSE7766_RX_ID,
  // 433 MHz SAW Radio transceivers  
  GPIO_RF_433MHZ_RX_ID, GPIO_RF_433MHZ_TX_ID,
  // Serial pins (Auto detect hardware vs serial)
  // GPIO_SERIAL_TX_ID, GPIO_SERIAL_RX_ID, //phase out to more specific one below
  GPIO_HWSERIAL0_TX_ID, GPIO_HWSERIAL0_RX_ID,
  GPIO_HWSERIAL1_TX_ID, GPIO_HWSERIAL1_RX_ID,
  GPIO_HWSERIAL2_TX_ID, GPIO_HWSERIAL2_RX_ID,
  GPIO_SWSERIAL0_TX_ID, GPIO_SWSERIAL0_RX_ID,
  // RingBuffers are used on the receive data (PHASE OUT)
  GPIO_HWSERIAL0_RING_BUFFER_TX_ID, GPIO_HWSERIAL0_RING_BUFFER_RX_ID,       // RinfBuffer GPIO should be removed, and instead be a special mode of the serial class. Simply set TX/RX, then with another command enable ringbuffer when desired. 
  GPIO_HWSERIAL1_RING_BUFFER_TX_ID, GPIO_HWSERIAL1_RING_BUFFER_RX_ID,
  GPIO_HWSERIAL2_RING_BUFFER_TX_ID, GPIO_HWSERIAL2_RING_BUFFER_RX_ID,

  GPIO_SERIAL_DEBUG_TX_ID, GPIO_SERIAL_DEBUG_RX_ID,
  // GPS Serial0 on both esp devices (1 of 3)
  GPIO_GPS_SERIAL0_TX_ID, GPIO_GPS_SERIAL0_RX_ID,
  // /**
  //  * @brief MAVLink Decoder
  //  **/
  // GPIO_MAVLINK_DECODER_HWSERIAL0_TX_ID, GPIO_MAVLINK_DECODER_HWSERIAL0_RX_ID,
  // GPIO_MAVLINK_DECODER_HWSERIAL1_TX_ID, GPIO_MAVLINK_DECODER_HWSERIAL1_RX_ID,
  // GPIO_MAVLINK_DECODER_HWSERIAL2_TX_ID, GPIO_MAVLINK_DECODER_HWSERIAL2_RX_ID,
  // /**
  //  * @brief MAVLink Telemetry Passthrough
  //  **/
  // GPIO_MAVLINK_TELEMETRY_HWSERIAL0_TX_ID, GPIO_MAVLINK_TELEMETRY_HWSERIAL0_RX_ID,
  // GPIO_MAVLINK_TELEMETRY_HWSERIAL1_TX_ID, GPIO_MAVLINK_TELEMETRY_HWSERIAL1_RX_ID,
  // GPIO_MAVLINK_TELEMETRY_HWSERIAL2_TX_ID, GPIO_MAVLINK_TELEMETRY_HWSERIAL2_RX_ID,
  // Rotary switch
  GPIO_ROT1A_ID, GPIO_ROT1B_ID, GPIO_ROT2A_ID, GPIO_ROT2B_ID,
  // Motion: PIR
  GPIO_PIR_1_ID, GPIO_PIR_2_ID, GPIO_PIR_3_ID,         //pullup
  GPIO_PIR_1_INV_ID, GPIO_PIR_2_INV_ID, GPIO_PIR_3_INV_ID, //pulldown
  // Motion: ? other for later!


  // Link/Status led
  // Phase out link leds, it will default to led1
  // GPIO_LEDLNK_ID, GPIO_LEDLNK_INV_ID,     // Inverted link led
  // Arilux RF Receive input
  GPIO_ARIRFRCV_ID, GPIO_ARIRFSEL_ID,
  // Buzzer
  GPIO_BUZZER_ID, GPIO_BUZZER_INV_ID,
  // GPS Serial
  GPIO_GPS_NMEA_RX_ID, GPIO_GPS_NMEA_TX_ID,
  // Basic IO for door closed/lock position
  GPIO_DOOR_LOCK_ID, GPIO_DOOR_OPEN_ID,
  // Nextion Touch panels 
  GPIO_NEXTION_RX_ID, GPIO_NEXTION_TX_ID, GPIO_BACKLIGHT_ID,      // Display backlight control
  GPIO_NEXTION_RX2_ID, GPIO_NEXTION_TX2_ID,      // Serial2 for Nextion
  // Door bell chime (basic relay controls) - // Should be replaced as switch maybe?
  GPIO_CHIME_INPUT_ID, GPIO_CHIME_RINGER_ID,   // Relay silenoid
  // L9110 chip H-brige motor driver
  GPIO_HBRIDGE_L9110_IA_ID, GPIO_HBRIDGE_L9110_IB_ID, GPIO_HBRIDGE_L9110_OA_ID, GPIO_HBRIDGE_L9110_OB_ID, //GPIO_HBRIDGE_ANALOG_SENSE_ID, //analog pin to use for sensing   //change to use anolog sensor class that updates automatically
  // Analog measuring types
  GPIO_ANALOG_POSITION_ID,
  // PC Fan controls using PWM
  GPIO_FAN_PWM1_ID,
  // Shelly 2.5 Energy Sensor with I2C
  GPIO_ADE7953_IRQ_ID,
  // Shelly Dimmer 2 MCU
  GPIO_SHELLY2_SHD_BOOT0_ID, GPIO_SHELLY2_SHD_RESET_INV_ID,
  // ADC options
  GPIO_ADC0_TEMPERATURE_ID,
  //
  GPIO_PULSE_COUNTER_ID,         // 
  GPIO_FAN_IRSEND_ID,        // Calls ceiling fan class to use IR sender
  // Displays
  GPIO_OLED_RESET_ID,
  /**
   * Analog Pins esp32
   * Adding GPIO number here, as ADC number is tied with physical gpio number (not mux'ed)
   * */
  GPIO_ADC1_CH4_ID,
  GPIO_ADC1_CH6_ID,
  GPIO_ADC1_CH7_ID,
  GPIO_ADC1_EXTERNAL_INTERRUPT_TRIGGER_ID,
  /**
   * Special cases
   * */
  GPIO_FUNCTION_RXON_SAMPLING_ENABLED_ID,
  GPIO_FUNCTION_CC1110_SYNC_PULSE_SIGNAL_ID,
  /**
   * @brief Fona Cellular
   **/
  GPIO_FUNCTION__FONA_POWER_KEY__ID,
  GPIO_FUNCTION__FONA_POWER_STATUS__ID,
  GPIO_FUNCTION__FONA_NETWORK_STATUS__ID,
  GPIO_FUNCTION__FONA_RESET__ID,
  GPIO_FUNCTION__FONA_UART_TX__ID,
  GPIO_FUNCTION__FONA_UART_RX__ID,
  GPIO_FUNCTION__FONA_RING_INDICATOR__ID,
  // Modem
  GPIO_FUNCTION__MODEM_DATA_TERMINAL_READY_DTR__ID,
  GPIO_FUNCTION__MODEM_TX__ID,
  GPIO_FUNCTION__MODEM_RX__ID,
  GPIO_FUNCTION__MODEM_POWER__ID,
  /**
   * @note All esp32 only options below this point
   * */
  // Webcamera
  GPIO_WEBCAM_XCLK_ID,     // 0       (I)O                GPIO0, CAM_XCLK
  GPIO_WEBCAM_DATA1_ID, GPIO_WEBCAM_DATA2_ID, GPIO_WEBCAM_DATA3_ID, GPIO_WEBCAM_DATA4_ID, GPIO_WEBCAM_DATA5_ID, GPIO_WEBCAM_DATA6_ID, GPIO_WEBCAM_DATA7_ID, GPIO_WEBCAM_DATA8_ID,  // 35      I   NO PULLUP       GPIO35, CAM_DATA8
  GPIO_WEBCAM_PCLK_ID,     // 22      IO      LED         GPIO22, CAM_PCLK
  GPIO_WEBCAM_HREF_ID,     // 23      IO                  GPIO23, CAM_HREF
  GPIO_WEBCAM_VSYNC_ID,    // 25      IO                  GPIO25, CAM_VSYNC
  GPIO_WEBCAM_SIOD_ID,     // 26      IO                  GPIO26, CAM_SIOD
  GPIO_WEBCAM_SIOC_ID,     // 27      IO                  GPIO27, CAM_SIOC
  GPIO_WEBCAM_PWDN_ID,     // 32      IO                  GPIO32, CAM_PWDN
  GPIO_WEBCAM_RESET_ID,
  #ifdef USE_MODULE_SENSORS_GPS_SERIAL
  // GPS Serial1 and 2 available on esp32 (2 of 3 ports)
  GPIO_GPS_SERIAL1_TX_ID, GPIO_GPS_SERIAL1_RX_ID,
  GPIO_GPS_SERIAL2_TX_ID, GPIO_GPS_SERIAL2_RX_ID,
  #endif
  #ifdef USE_MODULE_DRIVERS_SDCARD
  /**
   * SD Cards
   * */
  GPIO_FUNCTION_SDCARD_VSPI_CSO_ID, GPIO_FUNCTION_SDCARD_VSPI_CLK_ID, 
  GPIO_FUNCTION_SDCARD_VSPI_MOSI_ID, GPIO_FUNCTION_SDCARD_VSPI_MISO_ID,
  
  GPIO_FUNCTION_SDCARD_HSPI_CSO_ID, GPIO_FUNCTION_SDCARD_HSPI_CLK_ID, 
  GPIO_FUNCTION_SDCARD_HSPI_MOSI_ID, GPIO_FUNCTION_SDCARD_HSPI_MISO_ID,
  #endif // USE_MODULE_DRIVERS_SDCARD  
  GPIO_SENSOR_END_ID 
}; // used 171of 250

/**
 * @brief Programmer selectable GPIO functionality
 */
enum ProgramSelectablePins {
  GPIO_FIX_START_ID = 251,
  GPIO_SPI_MISO_ID,       // SPI MISO library fixed pin GPIO12
  GPIO_SPI_MOSI_ID,       // SPI MOSI library fixed pin GPIO13
  GPIO_SPI_CLK_ID,        // SPI Clk library fixed pin GPIO14
  GPIO_USER_ID=9999,           // User configurable needs to be 255
  GPIO_MAX_ID };





#include "1_TaskerManager/mTaskerInterface.h"

class mHardwarePins :
  public mTaskerInterface
{
  public:
    /************************************************************************************************
     * SECTION: Construct Class Base
     ************************************************************************************************/
    mHardwarePins(){};
    int8_t Tasker(uint8_t function, JsonParserObject obj = 0);
    void Pre_Init(void);
        
    static constexpr const char* PM_MODULE_CORE_HARDWAREPINS_CTR = D_MODULE_CORE_HARDWAREPINS_CTR;
    PGM_P GetModuleName(){          return PM_MODULE_CORE_HARDWAREPINS_CTR; }
    uint16_t GetModuleUniqueID(){ return D_UNIQUE_MODULE_CORE_HARDWAREPINS_ID; }
    
    struct ClassState
    {
      uint8_t devices = 0; // sensors/drivers etc, if class operates on multiple items how many are present.
      uint8_t mode = ModuleStatus::Initialising; // Disabled,Initialise,Running
    }module_state;

    /************************************************************************************************
     * SECTION: DATA_RUNTIME saved/restored on boot with filesystem
     ************************************************************************************************/


    /************************************************************************************************
     * SECTION: Internal Functions
     ************************************************************************************************/


    /************************************************************************************************
     * SECTION: Commands
     ************************************************************************************************/

    void parse_JSONCommand(JsonParserObject obj);

    /************************************************************************************************
     * SECTION: Construct Messages
     ************************************************************************************************/


     /************************************************************************************************
     * SECITON: MQTT
     ************************************************************************************************/
    



     /************************************************************************************************
     * SECITON: sort below
     ************************************************************************************************/
    
        

    int8_t GetPinByIndex(uint8_t index);
    int8_t GetPinIndexedLocation(uint8_t pin_number);
    bool SetPinFunction(int8_t gpio_pin_number, int8_t pin_function);

    bool flag_serial_set_tx_set = false;

    /**
     * Module that is attached to the pin, indexed by ascending order of pins available on chip
     */
    uint16_t pin_attached_gpio_functions[MAX_USER_PINS] = {0};  


    // User selectable ADC functionality
    enum UserSelectableAdc {
      ADC_NONE,           // Not used
      ADC_INPUT,          // Analog input
      ADC_TEMP,           // Thermistor
      ADC_LIGHT,          // Light sensor
      ADC_BUTTON,         // Button
      ADC_BUTTON_INV,
      ADC_RANGE,          // Range
      ADC_CT_POWER,       // Current
      ADC_JOY,            // Joystick
      ADC_PH,             // Analog PH Sensor
    //  ADC_SWITCH,         // Switch
    //  ADC_SWITCH_INV,
      ADC_END };


    #define GPIO_FLAG_USED         2  // Currently two flags used

    #define GPIO_FLAG_ADC0_ID      1  // Allow ADC0 when define USE_ADC_VCC is disabled
    #define GPIO_FLAG_ADC0_TEMP    2  // Allow ADC0 as Temperature sensor when define USE_ADC_VCC is disabled
    #define GPIO_FLAG_SPARE02      4
    #define GPIO_FLAG_SPARE03      8
    #define GPIO_FLAG_SPARE04     16
    #define GPIO_FLAG_SPARE05     32
    #define GPIO_FLAG_SPARE06     64
    #define GPIO_FLAG_SPARE07    128


    static const uint16_t GPIO_Function_EnabledList_IDs[] PROGMEM;

    /**
     * @brief This contains indexing for esp8266 THEN esp8285, the index (value) is important for retrieving template from either esp8266 or esp8285 arrays
     **/
    #ifdef ESP8266
    // Supported hardware modules. Leave completed list
    enum SupportedModules_8266_StaticCompleteList {
      MODULE_WEMOS_ID,    //should be renamed as generic so esp32/esp8266 can fallback this
      MODULE_SONOFF_BASIC_ID,
      MODULE_SONOFF_BASIC_EXTERNAL_ID, // tmp solution until both fixed modules can also have extra gpio added on top of default templates eg adding key2 to basic
      MODULE_H801_ID,
      MODULE_MAGICHOME_ID,
      MODULE_SHELLY1_ID,
      MODULE_SHELLY2P5_ID,
      MODULE_SHELLY_DIMMER2_ID,
      #ifdef USE_MODULE_TEMPLATE_SONOFF_IFAN03 // I probably dont want these here, to keep this list the same, but array method below is wrong with it
      MODULE_SONOFF_IFAN03_ID,
      #endif // USE_MODULE_TEMPLATE_SONOFF_IFAN03
      MODULE_SONOFF_4CHPRO_ID,
      // Last module
      MODULE_MAXMODULE_8266 // moved to dynamic ID list so it allows changing array size
    };
    #define MODULE_DEFAULT 0
    static const uint16_t ModuleList_Enabled_IDs[]      PROGMEM;
    static const char     ModuleList_Names_DList[]      PROGMEM;
    static const mytmplt8266  ModuleTemplate_GPIO_Map[] PROGMEM;
    #endif


    #ifdef ESP32
    // Supported hardware modules
    enum SupportedModules_ESP32_Base {
      MODULE_DOIT_DEVKIT,
      MODULE_CAM_AITHINKER_ID,
      MAXMODULE 
    };
    #define MODULE_DEFAULT 0
    static const uint16_t ModuleList_Enabled_IDs[]  PROGMEM;
    static const char     ModuleList_Names_DList[]  PROGMEM;
    static const mytmplt  ModuleTemplate_GPIO_Map[] PROGMEM;
    #endif

    int8_t ConvertRealPinToIndexPin(uint8_t real_pin);
    void ModuleSettings_FlashSerial();        
    void ParseModuleTemplate();
    void ModuleSettings_ShowTemplateLog();


    int8_t GetRealPinNumberFromName(const char* c);
    int16_t GetGPIOFunctionIDbyName(const char* c);

    void ModuleSettings_ShowActiveTemplate();
    
    int16_t     GetModuleIDbyName(const char* c);
    const char* GetModuleNameByID(uint8_t id);

    void GpioInitPwm(void);
    
    bool UsuableGPIOPin(uint8_t pin);

    const char* GetGPIOFunctionNamebyID(uint16_t id, char* buffer, uint8_t buflen);
    PGM_P GetGPIOFunctionNamebyID_P(uint16_t id);

    bool ValidUserGPIOFunction(uint8_t* pin_array, uint8_t index);
    bool ValidUserGPIOFunction(uint16_t* pin_array, uint8_t index);

    int16_t IRAM_ATTR Pin(uint32_t gpio, uint32_t index = 0);
    boolean PinUsed(uint32_t gpio, uint32_t index = 0);
    void SetPin(uint32_t lpin, uint32_t gpio);

    int16_t GetPinWithGPIO(uint16_t gpio, uint8_t index = 0);
    uint32_t GetPin(uint32_t gpio, uint32_t index = 0);

    void DigitalWrite(uint32_t gpio_pin, uint32_t state);
    void DigitalWrite(uint32_t gpio_pin, uint32_t index, uint32_t state);
    bool DigitalRead(uint32_t gpio_pin, uint32_t index = 0);
    
    uint8_t ModuleNr();
    bool ValidTemplateModule(uint8_t index);
    bool ValidModule(uint8_t index);
    
    const char* AnyModuleName(uint8_t index);
    const char* ModuleName();

    void GpioInit(void);
    void TemplateGPIOs(myio *gp);
    gpio_flag ModuleFlag();
    void ModuleDefault(uint8_t module);
    void SetModuleType();
    uint16_t ValidPin_AdjustGPIO(uint8_t pin, uint16_t gpio);
    bool ValidGPIO(uint8_t pin, uint16_t gpio);
    bool GetUsedInModule(uint8_t val, uint8_t *arr);
    bool JsonTemplate(const char* dataBuf);
    void TemplateJson();


    void ModuleTemplate__ParseCJSONBuffer(char* buffer);
    int8_t ConvertIndexPinToRealPin(uint8_t real_pin);


};

#endif 
